# A0139819N
###### /java/seedu/ticktask/logic/commands/EditCommand.java
``` java
        if (editTaskDescriptor.getTaskType().toString().equals("Optional[floating]")) {

            if (taskToEdit.getTaskType().getValue().equals("floating")) {
                throw new ParseException("Task is already floating!");
            } else {
                updatedTime = new DueTime("");
                updatedDate = new DueDate("");
            }
        }
```
###### /java/seedu/ticktask/logic/commands/RedoCommand.java
``` java
package seedu.ticktask.logic.commands;

import static java.util.Objects.requireNonNull;

import java.util.EmptyStackException;

import seedu.ticktask.logic.commands.exceptions.CommandException;


public class RedoCommand extends Command {
    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Redo an existing command that was previously undone by the user.";

    public static final String MESSAGE_SUCCESS = "Redo successful!";
    public static final String MESSAGE_FAILURE = "Redo failed! TickTask is already at latest state.";

    @Override
    public CommandResult execute() throws CommandException {
        requireNonNull(model);
        try {
            model.redoUndoneCommand();
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (EmptyStackException e) {
            throw new CommandException(MESSAGE_FAILURE);
        }

    }

}
```
###### /java/seedu/ticktask/logic/commands/UndoCommand.java
``` java
package seedu.ticktask.logic.commands;

import static java.util.Objects.requireNonNull;

import java.util.EmptyStackException;

import seedu.ticktask.logic.commands.exceptions.CommandException;


public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo a previously completed action on TickTask.";

    public static final String MESSAGE_SUCCESS = "Undo successful!";
    public static final String MESSAGE_FAILURE = "Undo failed! TickTask could not find any existing previous commands.";


    @Override
    public CommandResult execute() throws CommandException {
        requireNonNull(model);
        try {
            model.undoPreviousCommand();
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (EmptyStackException e) {
            throw new CommandException(MESSAGE_FAILURE);
        }

    }


}
```
###### /java/seedu/ticktask/model/Model.java
``` java
    /** Undo a previously completed action on the TickTask program*/
    void undoPreviousCommand() throws EmptyStackException;

    /**Redo a previously undone action on the TickTask program*/
    void redoUndoneCommand() throws EmptyStackException;
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java

    /**Reverses the previous command executed by the user
     * Restores the TickTask client to one state before the previous command was executed
     * */
    public void undoPreviousCommand() {
        TickTask currentTickTaskInstance = new TickTask(currentProgramInstance);
        currentProgramInstance.resetData(previousProgramInstances.pop());
        futureProgramInstances.push(currentTickTaskInstance);
        indicateTickTaskModelChanged();
    }

    /**Redo an existing command that was previously undone by the user
     * Restores the TickTask client to one state after the undone command was executed
     * User can only use redo command after an undo command was previously executed
     */
    public void redoUndoneCommand() {
        TickTask currentTickTaskInstance = new TickTask(currentProgramInstance);
        currentProgramInstance.resetData(futureProgramInstances.pop());
        previousProgramInstances.push(currentTickTaskInstance);
        indicateTickTaskModelChanged();
    }
    
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java
    /**Saves the current instance of the TickTask program before any data is modified
     * so that the program can return to previous instances if desired
     */
    private void saveInstance() {
        previousProgramInstances.push(new TickTask(currentProgramInstance));
        futureProgramInstances.clear();
    }
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java
    public TickTask getCurrentProgramInstance() {
        return currentProgramInstance;
    }

    public void setCurrentProgramInstance(TickTask currentProgramInstance) {
        this.currentProgramInstance = currentProgramInstance;
    }
    
    public Stack<TickTask> getPreviousProgramInstances() {
        return previousProgramInstances;
    }
    
    public void setPreviousProgramInstances(Stack<TickTask> previousProgramInstances) {
        this.previousProgramInstances = previousProgramInstances;
    }

    public Stack<TickTask> getFutureProgramInstances() {
        return futureProgramInstances;
    }

    public void setFutureProgramInstances(Stack<TickTask> futureProgramInstances) {
        this.futureProgramInstances = futureProgramInstances;
    }
```
###### /java/seedu/ticktask/model/task/DueDate.java
``` java
    public static final String DATE_REGEX_SINGLE = "\\d{2}?/\\d{2}?/\\d{4}?";
    public static final String DATE_REGEX_RANGE = "\\d{2}?/\\d{2}?/\\d{4}?\\-\\d{2}?/\\d{2}?/\\d{4}?";
```
###### /java/seedu/ticktask/model/task/Task.java
``` java

    /**
     * Resets the task type based on the due date and due time of the task object
     */
    public void resetTaskType() {
        if (time.isRange() || date.isRange()) {
            type.setValue(TaskType.TASK_TYPE_EVENT);
            if (time.getStartTime().equals("")) time.setStartTime(LocalTime.parse("00:00"));
            if (date.getStartDate().equals("")) date.setStartDate(LocalDate.now());
            if (time.getEndTime().equals("")) time.setEndTime(LocalTime.parse("23:59"));
            if (date.getEndDate().equals("")) date.setEndDate(LocalDate.now());
        } else if (time.isFloating() && date.isFloating()) {
            type.setValue(TaskType.TASK_TYPE_FLOATING);
        } else {
            type.setValue(TaskType.TASK_TYPE_DEADLINE);
            if (time.getStartTime().equals("")) time.setStartTime(LocalTime.parse("23:59"));
            if (date.getStartDate().equals("")) date.setStartDate(LocalDate.now());

            if (!date.getEndDate().equals("")) date.setEndDate(null);
            if (!time.getEndTime().equals("")) time.setEndTime(null);

        }
    }
```
###### /java/seedu/ticktask/model/task/Task.java
``` java

    @Override
    public TaskType getTaskType() {
        return type;
    }

    public void setDate(DueDate date) {
        this.date = requireNonNull(date);
    }

    @Override
    public DueDate getDate() {
        return date;
    }

    public boolean getCompleted() {
    	return this.completed;
    }

    public void setCompleted(boolean newStatus) {
        this.completed = newStatus;
    }

    /**
     * Returns an immutable tag set, which throws {@code UnsupportedOperationException}
     * if modification is attempted.
     */
    @Override
    public Set<Tag> getTags() {
        return Collections.unmodifiableSet(tags.toSet());
    }

    /**
     * Replaces this task's tags with the tags in the argument tag set.
     */
    public void setTags(Set<Tag> replacement) {
        tags.setTags(new UniqueTagList(replacement));
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        requireNonNull(replacement);

        this.setName(replacement.getName());
        this.setTime(replacement.getTime());
        this.setTaskType(replacement.getTaskType());
        this.setDate(replacement.getDate());
        this.setTags(replacement.getTags());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, time, type, date, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }
    
```
