# A0139964M
###### /java/seedu/ticktask/logic/commands/AddCommand.java
``` java
            if (!toAdd.isChronological()){
                return new CommandResult(String.format(MESSAGE_PAST_TASK, toAdd));
            }
```
###### /java/seedu/ticktask/logic/commands/EditCommand.java
``` java
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the details of the task identified"
            + "by the index number used in the last task listing."
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive integer) "
            + "[" + PREFIX_NAME + "NAME] "
            + "[" + PREFIX_TIME + "TIME] "
            + "[" + PREFIX_DATE + "DATE] "
            + "[" + PREFIX_TAG + "TAG]...\n"
            + "Example: " + COMMAND_WORD + " 1 "
            + PREFIX_NAME + "Final report submission "
            + PREFIX_DATE + "08/26/17";
```
###### /java/seedu/ticktask/logic/commands/EditCommand.java
``` java
            if (!editedTask.isChronological()) {
                return new CommandResult(String.format(MESSAGE_PAST_TASK, taskToEdit));
            }
```
###### /java/seedu/ticktask/logic/parser/ParseAddCommand.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class ParseAddCommand {

	public static final Pattern ADD_COMMAND_FORMAT =
			Pattern.compile("(?<name>(.(?!\\bby\\b|\\bfrom\\b|#|\\bat\\b))+)" 
					+ "(?=.*(by|from)\\s(?<dates>(.(?!.*'|#|\\bat\\b))+)?)?"
					+ "(?=.*(at)\\s(?<time>(.(?!.*'|#))+)?)?"
					+ "((?=.*#(?<tags>.+)))?"
					+ ".*");

	private Set<Tag> tagList;

	/**
	 * Parses the given {@code String} of arguments in the context of the AddCommand
	 * and returns an AddCommand object for execution.
	 * @throws ParseException if the user input does not conform the expected format
	 */
	public AddCommand parse(String args) throws ParseException {
		Matcher matcher = ADD_COMMAND_FORMAT.matcher(args.trim());

		if (!matcher.matches()) {
			throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		}
		try {
			Optional<String> parsename = Optional.ofNullable(matcher.group("name"));
			Optional<String> parsedate = Optional.ofNullable(matcher.group("dates"));
			Optional<String> parsetime = Optional.ofNullable((matcher.group("time")));
			Optional<String> parsetag = Optional.ofNullable((matcher.group("tags")));
			tagList = createTagList(parsetag);
			Name name = ParserUtil.parseName(parsename).get();
			DueTime time = ParserUtil.parseTime(parsetime).get();
			TaskType type = ParserUtil.parseTaskType(Optional.of(" ")).get();
			DueDate date = ParserUtil.parseDate(parsedate).get();


			ReadOnlyTask task = new Task(name, time, type, date, tagList);

			return new AddCommand(task);
		} catch (IllegalValueException ive) {
			throw new ParseException(ive.getMessage(), ive);
		}
	}

	public Set<Tag> createTagList(Optional<String> parsetag) throws IllegalValueException {
		if (parsetag.isPresent()) {
			String[] stringArray = parsetag.get().split(" ");
			Collection<String> tagCollection = Arrays.asList(stringArray);
			HashSet<String> tagsList = new HashSet<>(tagCollection);
			tagList = ParserUtil.parseTags(tagsList);
		} else {
			HashSet<String> emptyTagList = new HashSet<String>();
			tagList = ParserUtil.parseTags(emptyTagList);
		}
		return tagList;
	}
}
```
###### /java/seedu/ticktask/logic/parser/ParseEditCommand.java
``` java
public class ParseEditCommand {

	public static final String COMMAND_ARGUMENTS_REGEX = "(?=(?<index>\\d+))"
			+ "(?:(?=.*name (?:(?<name>.+?)(?:,|$|\\R|date|time))?))?"
			+ "(?:(?=.*type (?:(?<type>.+?)(?:,|$|\\R|date|time))?))?"
			+ "(?:(?=.*date(?:(?<date>.+?)(?:,|$|\\R|time))?))?"
			+ "(?:(?=.*time(?:(?<time>.+?)(?:,|$|\\R|date))?))?"
			+ "((?=.*#(?<tags>.+)))?"
			+ ".+";

	public static final Pattern COMMAND_ARGUMENTS_PATTERN = Pattern.compile(COMMAND_ARGUMENTS_REGEX);

	private Set<Tag> tagList;

	public EditCommand parse(String args) throws IllegalValueException {
		Matcher matcher = COMMAND_ARGUMENTS_PATTERN.matcher(args.trim());

		if (!matcher.matches()) {
			throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
		}
		
		int index = Integer.parseInt(matcher.group("index"));

		Optional<String> name = Optional.ofNullable(matcher.group("name"));
		Optional<String> time = Optional.ofNullable(matcher.group("time"));
		Optional<String> date = Optional.ofNullable(matcher.group("date"));
		Optional<String> tags = Optional.ofNullable(matcher.group("tags"));
		Optional<String> type = Optional.ofNullable(matcher.group("type"));

		if(!name.isPresent() && !time.isPresent() && !date.isPresent() && !tags.isPresent() && !type.isPresent()){
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
		EditCommand.EditTaskDescriptor editTaskDescriptor = new EditCommand.EditTaskDescriptor();
		try {
			ParserUtil.parseName(name).ifPresent(editTaskDescriptor::setName);
			ParserUtil.parseTaskType(type).ifPresent(editTaskDescriptor::setTaskType);
			ParserUtil.parseTime(time).ifPresent(editTaskDescriptor::setTime);
			ParserUtil.parseDate(date).ifPresent(editTaskDescriptor::setDate);
			tagList = createTagList(tags);
			editTaskDescriptor.setTags(tagList);
		} catch (IllegalValueException ive) {
			throw new ParseException(ive.getMessage(), ive);
		}
		try {
			Index index1 = Index.fromOneBased(index);
			return new EditCommand(index1, editTaskDescriptor);
		} catch (IndexOutOfBoundsException iobe){
			throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
		}
	}

	public Set<Tag> createTagList(Optional<String> parsetag) throws IllegalValueException {
		if (parsetag.isPresent()) {
			String[] stringArray = parsetag.get().split(" ");
			Collection<String> tagCollection = Arrays.asList(stringArray);
			HashSet<String> tagsList = new HashSet<>(tagCollection);
			tagList = ParserUtil.parseTags(tagsList);
		}
		return tagList;
	}
```
###### /java/seedu/ticktask/model/task/Task.java
``` java
    /**
     * Checks if the task added is in the past.
     * @param task
     * @return boolean
     */
    public boolean isChronological() {
        LocalDate currDate = LocalDate.now();

        if(this.getDate().getLocalStartDate() == null){
            if(this.getTime().getLocalStartTime() == null || isTimeChronological()){
                return true;
            }
            else return false;
        }
        LocalDate taskDate = this.getDate().getLocalStartDate();
        //Check if task's is today.
        if(taskDate.isEqual(currDate)){
            if(this.getTime().getLocalStartTime() == null|| isTimeChronological()){
                return true;
            } else {
                return false;
            }
        }
        if(isDateChronological()){
            return true;
        } else{
            return false;
        }
    }

    public boolean isTimeChronological() {
        LocalTime currTime = LocalTime.now();
        LocalTime taskTime = this.getTime().getLocalStartTime();
        if (taskTime.isBefore(currTime)) {
            return false;
        } else {
            return true;
        }
    }

    public boolean isDateChronological(){
        LocalDate currDate = LocalDate.now();
        LocalDate taskDate = this.getDate().getLocalStartDate();
        if(taskDate.isBefore(currDate)){
            return false;
        } else {
            return true;
        }
    }
```
###### /java/seedu/ticktask/model/task/Task.java
``` java
    /**
     * Check if the current task's date is due. Applies to only deadline & event
     *true if and only if current date is after start date
     */
    public boolean isDateDue() {
        LocalDate now = LocalDate.now();
        LocalDate taskDate = date.getLocalStartDate();
        if (now.isAfter(taskDate)) {
            return true;
        } else {
            return false;
        }
    }
    /**
     * Check if the current task's time is due. Applies to only deadline & event
     *true if and only if current time is after start time
     */
    public boolean isTimeDue() {
        LocalTime now = LocalTime.now();
        LocalTime taskTime = time.getLocalStartTime();
        if (now.isAfter(taskTime)) {
            return true;
        } else {
            return false;
        }
    }
    /**
     * Get the time in hours if time is less than 1 day (24 hours)
     *Applies to only deadline and events
     */
    public Duration getDueDurationTime() {
        LocalTime now = LocalTime.now();
        LocalTime startTime = time.getLocalStartTime();
        return Duration.between(now, startTime);
    }
    /**
     * Get the time in days if days is >= 1
     *Applies to only deadline and events
     */
    public long getDueDateDuration() {
        LocalDate now = LocalDate.now();
        LocalDate startDate = date.getLocalStartDate();
        long daysBetween = ChronoUnit.DAYS.between(now, startDate);
        return daysBetween;
    }
    /**
     * Check if the event is happening now.
     *Applies to only events
     */
    public boolean isHappening() {
        LocalDate nowDate = LocalDate.now();
        LocalDate startDate = date.getLocalStartDate();
        LocalTime nowTime = LocalTime.now();
        LocalTime startTime = time.getLocalStartTime();
        LocalTime endTime = time.getLocalEndTime();
        LocalDate endDate = date.getLocalEndDate();
        if(nowTime.isAfter(startTime) && nowTime.isBefore(endTime)){
            if(nowDate.isEqual(startDate) || (nowDate.isAfter(startDate) && nowDate.isBefore(endDate))){
                return true;
            } else {
                return false;
            }
        } else{
            return false;
        }
    }
}
```
###### /java/seedu/ticktask/ui/CommandBox.java
``` java
    private AutoCompletionBinding<String> autoCompletionBinding;
    Set listOfCommands = new HashSet<>();
    String[] commands = {"add", "delete", "edit", "list", "complete", "help", "undo", "redo", "find", "exit",
                        "save","clear"};
    
```
###### /java/seedu/ticktask/ui/CommandBox.java
``` java
    
    /**
     * Method that handles arrow up and down to cycle between commands
     *
     * @param event
     */
    @FXML
    private void handleKeyPress(KeyEvent event) {
        KeyCode key = event.getCode();
        switch (key) {
            case UP:
                String prevCommand = getPrevCommand(lastPrev);
                lastPrev = prevCommand;
                commandTextField.setText(prevCommand);
                return;
            case DOWN:
                String nextCommand = getNextCommand();
                commandTextField.setText(nextCommand);
                return;
            case ENTER:
                addSenteceToAutoComplete(commandTextField.getText());
                return;
        }
    }
    
	public void addSenteceToAutoComplete(String text){
		listOfCommands.add(text);
		if (autoCompletionBinding != null) {
			autoCompletionBinding.dispose();
		}
		
		autoCompletionBinding = TextFields.bindAutoCompletion(commandTextField, listOfCommands);
        autoCompletionBinding.setVisibleRowCount(1);
	}
    
	public String getPrevCommand(String lastPrev){
		if(!prevCommandsHistory.isEmpty()) {
			String prevCommand = prevCommandsHistory.pop();
			nextCommandsHistory.push(prevCommand);
			return prevCommand;
		}
		return lastPrev;
	}
	public String getNextCommand(){
		if(!nextCommandsHistory.isEmpty()) {
			String nextCommand = nextCommandsHistory.pop();
			prevCommandsHistory.push(nextCommand);
			return nextCommand;
		} else {
			return "";
		}
	}

	private void updatePrevCommand(String commandText){
		prevCommandsHistory.push(commandText);
	}
	/**
	 * Method that pops up an auto complete when a suitable keyword is inputted
	 */

	public void autoComplete(){
		buildCommandsIntoHashSet();
		autoCompletionBinding = TextFields.bindAutoCompletion(commandTextField, listOfCommands);
		autoCompletionBinding.setPrefWidth(300);
		autoCompletionBinding.setVisibleRowCount(1);
		autoCompletionBinding.setHideOnEscape(true);
	}

	public void buildCommandsIntoHashSet(){
		for(int i = 0; i < commands.length; i++){
			listOfCommands.add(commands[i]);
		}
	}
```
###### /java/seedu/ticktask/ui/CommandBox.java
``` java
			while(!nextCommandsHistory.isEmpty()){
				prevCommandsHistory.push(nextCommandsHistory.pop());
			}
			updatePrevCommand(commandText);
```
###### /java/seedu/ticktask/ui/TaskCard.java
``` java
    private static String MESSAGE_DISPLAY_DUE_IN = "Due in: ";
    private static String MESSAGE_DISPLAY_HAPPENING= "Happening";
    private static String MESSAGE_DISPLAY_OVER_DUE = "Over Due";
    private static String MESSAGE_DISPLAY_PASSED = "Passed";
    private static String MESSAGE_DISPLAY_STARTING_IN = "Starting in: ";
    private static String TASKTYPE_EVENT ="event";
    private static String TASKTYPE_DEADLINE ="deadline";
    private static String TASKTYPE_FLOATING ="floating";
```
###### /java/seedu/ticktask/ui/TaskCard.java
``` java
        taskType.setText(task.getTaskType().value.toUpperCase());
        if (task.getTaskType().getValue().equals(TASKTYPE_EVENT)){
            cardPane.setStyle("-fx-background-color: #ffe3b5;");
          taskType.setStyle("-fx-font-size: 10pt;-fx-text-fill: #ba7503;");
            if(!task.getCompleted()) {
                initializeEstimatedTimeForEvent(task);
            }
            else{
                button.setStyle("visibility: hidden;");
            }

        } else if (task.getTaskType().getValue().equals(TASKTYPE_DEADLINE)){
            cardPane.setStyle("-fx-background-color: #deffc4;");
          taskType.setStyle("-fx-font-size: 10pt;-fx-text-fill: #3a8202;");
            if(!task.getCompleted()) {
                initializeEstimatedTimeForDeadline(task);
            }
            else {
                button.setStyle("visibility: hidden;");
            }

        } else if (task.getTaskType().getValue().equals(TASKTYPE_FLOATING)){
            cardPane.setStyle("-fx-background-color: #ccecff;");
          taskType.setStyle("-fx-font-size: 10pt;-fx-text-fill: #0372b5;");
            button.setStyle("visibility: hidden;");
        }
        initTags(task);
    }
```
###### /java/seedu/ticktask/ui/TaskCard.java
``` java
    private void initTags(ReadOnlyTask task) {
        task.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }

    public void initializeEstimatedTimeForEvent(ReadOnlyTask task){
        if(task.isHappening()){
            button.setId("buttonHappening");
            button.setText(MESSAGE_DISPLAY_HAPPENING);
        } else if(task.isDateDue() || task.isTimeDue()){
            button.setId("buttonOverDue");
            setTextColor(id,name,time,date,taskType,Color.RED);
            button.setText(MESSAGE_DISPLAY_PASSED);
        } else if(task.getDueDateDuration() >= 1){
            button.setText(MESSAGE_DISPLAY_STARTING_IN + task.getDueDateDuration() + " days");
        }
        else{
            button.setText(MESSAGE_DISPLAY_STARTING_IN + DurationFormatUtils.formatDurationWords(task.getDueDurationTime().toMillis(),
                    true, true));
        }
    }

    public void initializeEstimatedTimeForDeadline(ReadOnlyTask task) {
        if (task.isDateDue() || task.isTimeDue()) {
            button.setId("buttonOverDue");
            setTextColor(id,name,time,date,taskType,Color.RED);
            button.setText(MESSAGE_DISPLAY_OVER_DUE);
        } else if (task.getDueDateDuration() >= 1) {
            button.setText(MESSAGE_DISPLAY_DUE_IN + task.getDueDateDuration() + " days");
        } else {
            button.setText(MESSAGE_DISPLAY_DUE_IN + DurationFormatUtils.formatDurationWords(task.getDueDurationTime().toMillis(),
                    true, true));
        }
    }
}
```
###### /resources/css/StyleSheet.css
``` css
.button{
    -fx-background-color: rgba(51, 153, 255, 0.5);
    -fx-border-radius: 5px;
    -fx-border: #4286f4;
    -fx-color: black;
    -fx-padding: 2px 5px;
    -fx-text-align: center;
    -fx-text-decoration: none;
    -fx-display: inline-block;
    -fx-font-size: 10pt;
    -fx-margin: 2px 2px;
    -fx-cursor: pointer;
}


#buttonOverDue{
    -fx-background-color: rgba(244, 98, 66, 0.5);
    -fx-border-radius: 5px;
    -fx-border: #4286f4;
    -fx-color: black;
    -fx-padding: 2px 5px;
    -fx-text-align: center;
    -fx-text-decoration: none;
    -fx-display: inline-block;
    -fx-font-size: 10pt;
    -fx-margin: 2px 2px;
    -fx-cursor: pointer;
}

#buttonHappening{
    -fx-background-color: rgba(91, 244, 65,0.5);
    -fx-border-radius: 5px;
    -fx-border: #4286f4;
    -fx-color: black;
    -fx-padding: 2px 5px;
    -fx-text-align: center;
    -fx-text-decoration: none;
    -fx-display: inline-block;
    -fx-font-size: 10pt;
    -fx-margin: 2px 2px;
    -fx-cursor: pointer;
}


```
