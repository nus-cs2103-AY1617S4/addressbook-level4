# A0131884B
###### /java/seedu/ticktask/commons/core/Messages.java
``` java
    public static final String MESSAGE_TASK_DESCRIPTION = "Description: ";
```
###### /java/seedu/ticktask/commons/util/StringUtil.java
``` java
    /**
     * Returns true if the {@code sentence} contains the {@code word}.
     *   Ignores case, but a full word match is required.
     *   <br>examples:<pre>
     *       containsStringIgnoreCase("ABc def", "abc") == false
     *       containsStringIgnoreCase("def", "DEF") == true
     *       containsStringIgnoreCase("ABC", "AB") == false //not a full word match
     *       </pre>
     * @param sentence cannot be null
     * @param string cannot be null, cannot be empty, must be a single word
     */
    public static boolean matchesStringIgnoreCase(String sentence, String string) {
        requireNonNull(sentence);
        requireNonNull(string);
        String preppedWord = string.trim().toLowerCase();
        checkArgument(!preppedWord.isEmpty(), "Word parameter cannot be empty");
        if (sentence.toLowerCase().equals(preppedWord)) {
            return true;
        }

        return false;
    }
```
###### /java/seedu/ticktask/logic/commands/ClearCommand.java
``` java

public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_SUCCESS = "The targeted list has been cleared!";
    public static final String MESSAGE_USAGE = COMMAND_WORD + " : Clear active tasks or clear completed tasks.\n"
            + "Example: " + COMMAND_WORD + " active\n"
            + "Example: " + COMMAND_WORD + " complete\n";
    public static final String MESSAGE_NOT_SUCCESS = "The clear command should be either 'clear active' or 'clear complete'.";
    private Prefix listIndicatorPrefix;

    public ClearCommand(Prefix listIndicatorPrefix) {
         this.listIndicatorPrefix = listIndicatorPrefix;
    }

    @Override
    public CommandResult execute() {
        requireNonNull(model);
        if (listIndicatorPrefix.toString().equals(PREFIX_ACTIVE.toString()))
        {
        	model.resetActiveData(new TickTask());
            return new CommandResult(MESSAGE_SUCCESS);
        }
        else if (listIndicatorPrefix.toString().equals(PREFIX_COMPLETE.toString())) {
            model.resetCompleteData(new TickTask());
            return new CommandResult(MESSAGE_SUCCESS);
        } else {
            return new CommandResult(MESSAGE_NOT_SUCCESS);
        }

    }
}
```
###### /java/seedu/ticktask/logic/commands/Command.java
``` java
    public abstract CommandResult execute() throws CommandException, IllegalValueException, DuplicateTaskException;;
```
###### /java/seedu/ticktask/logic/commands/DeleteCommand.java
``` java
  /*
   * Abstract class that represents what Command word and confirmation messages a delete command will be using.
   */
public abstract class DeleteCommand extends Command {
    public static final String COMMAND_WORD = "delete";
    public static final String MESSAGE_USAGE = COMMAND_WORD + " : Delete the task identified by keywords"
            + " if it is the only task found, \nor delete the task "
            + "identified by the index number of the last"
            + " task list.\n" + "Format: " + COMMAND_WORD
            + " [task name]\n" + "Example: " + COMMAND_WORD + " wash clothes\n"
            + "or " + COMMAND_WORD + " " + PREFIX_ACTIVE + " INDEX (must be a positive integer)"
            + " or " + COMMAND_WORD + " " + PREFIX_COMPLETE + " INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " "
            + PREFIX_COMPLETE + " 1";
    public static final String MESSAGE_SUCCESS = "Task deleted:" + "\n"
            + Messages.MESSAGE_TASK_DESCRIPTION + "%1$s";
    protected ReadOnlyTask taskToDelete;
}
```
###### /java/seedu/ticktask/logic/commands/DeleteFindCommand.java
``` java
    /*
    * Finds tasks from given task name and deletes task if it is the only one found.
    */
    public class DeleteFindCommand extends DeleteCommand {
        public static final String MESSAGE_NO_TASKS = "No tasks found! Please try again "
                 + "with different keywords. \nUse 'list' command to go back";

        public static final String MESSAGE_MULTIPLE_TASKS = "More than one task found! \n"
                 + "Use " + COMMAND_WORD + " [ "
                 + PREFIX_COMPLETE + " ]" + " or " + COMMAND_WORD + " [ "
                 + PREFIX_ACTIVE + " ]"
                 + " INDEX to specify which task to delete. \nUse 'list' command to go back after finishing deletion.";

        private Set<String> keywords;

        public DeleteFindCommand(Set<String> keywords) {
                this.keywords = keywords;
            }

        @Override
        public CommandResult execute() throws CommandException , DuplicateTaskException {
        /*
        * update all 2 lists with new keywords.
        */

            model.updateMatchedTaskList(keywords);
            /*
            * find out whether only 1 task is found.
            */
            List<ReadOnlyTask> tempList = new ArrayList<>();
            tempList.addAll(model.getFilteredTaskList());
            tempList.addAll(model.getFilteredCompletedTaskList());

            if (tempList.size() == 1) {
                taskToDelete = tempList.get(0);
            try {
                model.deleteFindTask(taskToDelete);
            } catch (TaskNotFoundException e) {
                assert false : "The target task cannot be missing";
            }
            model.updateFilteredListToShowAll();
            return new CommandResult(String.format(MESSAGE_SUCCESS, taskToDelete));
            } else {
                if (tempList.size() >= 2) {
                    return new CommandResult(MESSAGE_MULTIPLE_TASKS);
                } else {
                    assert (tempList.size() == 0);
                    return new CommandResult(MESSAGE_NO_TASKS);
                }
            }
        }
    }

```
###### /java/seedu/ticktask/logic/commands/DeleteIndexCommand.java
``` java
 /*
  * Deletes an task identified using the type of task followed by task index.
  */
  public class DeleteIndexCommand extends DeleteCommand {
       private Index targetIndex;
       private Prefix listIndicatorPrefix;

       public DeleteIndexCommand(Index targetIndex, Prefix listIndicatorPrefix) {
            this.targetIndex = targetIndex;
            this.listIndicatorPrefix = listIndicatorPrefix;
       }

       @Override
       public CommandResult execute() throws CommandException , DuplicateTaskException {
            UnmodifiableObservableList<ReadOnlyTask> listToDeleteFrom;
            assert listIndicatorPrefix != null;
            if (listIndicatorPrefix.equals(PREFIX_ACTIVE)) {
                  listToDeleteFrom = model.getFilteredTaskList();
            } else {
                  assert listIndicatorPrefix.equals(PREFIX_COMPLETE);
                  listToDeleteFrom = model.getFilteredCompletedTaskList();
            }
            
            if (targetIndex.getZeroBased() >= listToDeleteFrom.size()) {
                  throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }

            taskToDelete = listToDeleteFrom.get(targetIndex.getZeroBased());
                  try {
                         if (listIndicatorPrefix.equals(PREFIX_COMPLETE))
                             model.deleteIndexCompleteTask(taskToDelete);
                         else
                             model.deleteIndexActiveTask(taskToDelete);
                  } catch (TaskNotFoundException enfe) {
                         assert false : "The target list cannot be missing";
                  }

            return new CommandResult(String.format(MESSAGE_SUCCESS, taskToDelete));
       }

  }
 
```
###### /java/seedu/ticktask/logic/parser/ClearCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class ClearCommandParser {

    private ArgumentMultimap argMultimap;

        public ArgumentMultimap getArgMultimapDelete() {
                return argMultimap;
            }
        /**
         * Parses the given {@code String} of arguments in the context of the DeleteCommand and returns an
         * DeleteCommand object for execution.
         * @throws ParseException if the user input does not conform the expected format
         */
        
        public ClearCommand parse(String args) throws ParseException, IllegalValueException {
            argMultimap = ArgumentTokenizer.tokenize(args, PREFIX_COMPLETE, PREFIX_ACTIVE);
            if (args.trim().isEmpty()) {
            	throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
            			ClearCommand.MESSAGE_USAGE));
            }
            
            if (haveInvalidPrefixCombination(argMultimap)) {
                throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ClearCommand.MESSAGE_USAGE));
        	} 
            Prefix listIndicatorPrefix = ParserUtil.getListPrefix(argMultimap,  PREFIX_COMPLETE, PREFIX_ACTIVE);
			return new ClearCommand(listIndicatorPrefix);
        }   
            
        private boolean haveInvalidPrefixCombination(ArgumentMultimap argMultimap) {
            assert argMultimap != null;
            return ParserUtil.areAllPrefixesPresent(argMultimap, PREFIX_ACTIVE, PREFIX_COMPLETE);                  
        }
}
```
###### /java/seedu/ticktask/logic/parser/CliSyntax.java
``` java
    public static final Prefix PREFIX_COMPLETE = new Prefix("complete");
    public static final Prefix PREFIX_ACTIVE = new Prefix("active");
```
###### /java/seedu/ticktask/logic/parser/DeleteCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser {

    private ArgumentMultimap argMultimap;

        public ArgumentMultimap getArgMultimapDelete() {
                return argMultimap;
            }

    /**
    * Parses the given {@code String} of arguments in the context of the DeleteCommand and returns an
    * DeleteCommand object for execution.
    * @throws ParseException if the user input does not conform the expected format
    */
    public DeleteCommand parse(String args) throws ParseException {
                argMultimap = ArgumentTokenizer.tokenize(args, PREFIX_COMPLETE, PREFIX_ACTIVE);
        if (args.trim().isEmpty()) {
                throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                DeleteCommand.MESSAGE_USAGE));
         }

        /**
        * delete by index
        */
        if (hasIndexFlag(argMultimap)) {
        	if (hasInvalidPrefixCombination(argMultimap)) {
                throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                                       DeleteCommand.MESSAGE_USAGE));
        	}
            try {
                Prefix listIndicatorPrefix = ParserUtil.getListPrefix(argMultimap,  PREFIX_COMPLETE, PREFIX_ACTIVE);
                Index index = ParserUtil.parseIndex(argMultimap.getValue(listIndicatorPrefix).get());
                return new DeleteIndexCommand(index, listIndicatorPrefix);
            } catch (IllegalValueException ive) {
                throw new ParseException(ive.getMessage(), ive);
            }
        /**
        * delete by task name
        */
        } else {
            String trimmedArgs = argMultimap.getPreamble();
            final String[] keywords = new String[]{""};
            keywords [0] = trimmedArgs;
            final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
            return new DeleteFindCommand(keywordSet);
        }
    }

        /**
         * A method that returns true if flags are given in an illogical manner for deleting commands.
         * illogical := any 2 of /float, /deadline, /event used together.
         */
        private boolean hasInvalidPrefixCombination(ArgumentMultimap argMultimap) {
            assert argMultimap != null;
            return ParserUtil.areAllPrefixesPresent(argMultimap, PREFIX_ACTIVE, PREFIX_COMPLETE);                  
        }
       /**
          * A method that returns true if flags in given ArgumentMultimap has at least one index-indicating
          * Prefix mapped to some arguments.
          * Index-indicating : /active or /complete
          */
    private boolean hasIndexFlag(ArgumentMultimap argMultimap) {
        assert argMultimap != null;
        return ParserUtil.isPrefixPresent(argMultimap,  PREFIX_COMPLETE, PREFIX_ACTIVE);
    }
}



```
###### /java/seedu/ticktask/logic/parser/Parser.java
``` java
        case DeleteCommand.COMMAND_WORD:
            return new DeleteCommandParser().parse(arguments);
```
###### /java/seedu/ticktask/logic/parser/ParserUtil.java
``` java
   /**
    * Return prefix that has arguments mapped to it, and remove prefixes that are not mapped to anything in argMultimap
    */
    public static Prefix getListPrefix(ArgumentMultimap argMultimap, Prefix... prefixes) {
         List<Prefix> temp = Stream.of(prefixes).filter(prefix -> argMultimap.getValue(prefix).isPresent()).collect(Collectors.toList());
            assert (temp.size() <= 1) : "invalid flag combination not catched beforehand or no Prefixes found!";
            return temp.get(0);
    }

   /**
    * Returns true if any of the prefixes contain non-empty values in argMultimap
    */
    public static boolean isPrefixPresent(ArgumentMultimap argumentMultimap, Prefix... prefixes) {
         return Stream.of(prefixes).anyMatch(prefix -> argumentMultimap.getValue(prefix).isPresent());
    }
    
    /**
     * Returns true if none of the prefixes contains empty {@code Optional} values in the given
     * {@code ArgumentMultimap}.
     */
    public static boolean areAllPrefixesPresent(ArgumentMultimap argumentMultimap, Prefix... prefixes) {
        return Stream.of(prefixes).allMatch(prefix -> argumentMultimap.getValue(prefix).isPresent());
    }
    
    /**
     * Remove Prefix's not mapped to anything in ArgumentMultimap parameter, and returns prefix that has
     * arguments mapped to it. This means the mapping should be a one-one mapping.
     */
    public static Prefix getPrefix(ArgumentMultimap argMultimap, Prefix... prefixes) {
        List<Prefix> tempList = Stream.of(prefixes).filter(prefix -> argMultimap.getValue(prefix).isPresent())
                                  .collect(Collectors.toList());
        if (tempList.size() != 1) {
            assert false : "More than one or zero Prefixes is found";
        }
        return tempList.get(0);
    }
```
###### /java/seedu/ticktask/model/Model.java
``` java
    /** Deletes the given task using find task name method. */
    void deleteFindTask(ReadOnlyTask target) throws TaskNotFoundException, DuplicateTaskException;

    /** Deletes the given complete task using find task index method. */
    void deleteIndexCompleteTask(ReadOnlyTask target) throws TaskNotFoundException, DuplicateTaskException;

    /** Deletes the given active task using find task index method. */
    void deleteIndexActiveTask(ReadOnlyTask target) throws TaskNotFoundException, DuplicateTaskException;

    /** Clear active list. */
    void resetActiveData(ReadOnlyTickTask newData);

    /** clear complete list. */
    void resetCompleteData(ReadOnlyTickTask newData);
```
###### /java/seedu/ticktask/model/Model.java
``` java
    /** Updates the filter of the filtered task list if it matches the given keywords*/
    void updateMatchedTaskList(Set<String> keywords);
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java
    @Override
    public void updateMatchedTaskList(Set<String> keywords) {
        updateMatchedTaskList(new PredicateExpression(new NameQualifier(keywords)));

    }

    private void updateMatchedTaskList(Expression expression) {
        filteredActiveTasks.setPredicate(expression::matches);
        filteredCompletedTasks.setPredicate(expression::matches);
    }

    @Override

    /**Deletes the given task using find task name method.
          */
    public synchronized void deleteFindTask(ReadOnlyTask target) throws TaskNotFoundException, DuplicateTaskException {
        saveInstance();
        currentProgramInstance.removeFindTask(target);
        indicateTickTaskModelChanged();
    }
    /**Deletes the given active task using find task index method
          */
    public synchronized void deleteIndexActiveTask(ReadOnlyTask target) throws TaskNotFoundException, DuplicateTaskException {
        saveInstance();
        currentProgramInstance.removeIndexActiveTask(target);
        indicateTickTaskModelChanged();
    }


    public synchronized void deleteIndexCompleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        saveInstance();
        currentProgramInstance.removeIndexCompleteTask(target);
        indicateTickTaskModelChanged();
    }

    @Override
    public void resetActiveData(ReadOnlyTickTask newData) {
        saveInstance();
        currentProgramInstance.resetActiveData(newData);
        indicateTickTaskModelChanged();
    }

    @Override
    public void resetCompleteData(ReadOnlyTickTask newData) {
        saveInstance();
        currentProgramInstance.resetCompleteData(newData);
        indicateTickTaskModelChanged();
    }
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java
        // state check
        ModelManager other = (ModelManager) obj;
        return currentProgramInstance.equals(other.currentProgramInstance)
                && filteredActiveTasks.equals(other.filteredActiveTasks)
                                && filteredCompletedTasks.equals(other.filteredCompletedTasks);
    }
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java
        boolean matches(ReadOnlyTask task);
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java
        @Override
        public boolean matches(ReadOnlyTask task) {
            return qualifier.match(task);
        }
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java
        boolean match(ReadOnlyTask task);
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java
        @Override
        public boolean match(ReadOnlyTask task) {
            return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.matchesStringIgnoreCase(task.getName().fullName, keyword))
                    .findAny()
                    .isPresent();
        }
```
###### /java/seedu/ticktask/model/TickTask.java
``` java
   /**
    * Clear complete list
    * @param completedTasks is of type ReadOnlyTask
    * @return boolean
    */

    public void setCompleteData(List<? extends ReadOnlyTask> completedTasks) throws DuplicateTaskException {
        this.completedTasks.setTasks(completedTasks);
    }

    /**
     * Clear active list
     * @param tasks is of type ReadOnlyTask
     * @return boolean
     */
    public void setActiveData(List<? extends ReadOnlyTask> tasks) throws DuplicateTaskException {
        this.tasks.setTasks(tasks);
    }

    /**
     * Mark complete list to be cleared
     * @param newData is of type ReadOnlyTickTask
     * @return boolean
     */
    public void resetCompleteData(ReadOnlyTickTask newData) {
        requireNonNull(newData);
        try {
            setCompleteData(newData.getCompletedTaskList());
        } catch (DuplicateTaskException e) {
            assert false : "The TickTask program should not have duplicate tasks";
        }
        try {
            setTags(newData.getTagList());
        } catch (UniqueTagList.DuplicateTagException e) {
            assert false : "The TickTask program should not have duplicate tags";
        }
        syncMasterTagListWith(tasks);
    }

    /**
     * Mark active list to be cleared
     * @param newData is of type ReadOnlyTickTask
     * @return boolean
     */
    public void resetActiveData(ReadOnlyTickTask newData) {
        requireNonNull(newData);
        try {
            setActiveData(newData.getTaskList());
        } catch (DuplicateTaskException e) {
            assert false : "The TickTask program should not have duplicate tasks";
        }
        try {
            setTags(newData.getTagList());
        } catch (UniqueTagList.DuplicateTagException e) {
            assert false : "The TickTask program should not have duplicate tags";
        }
        syncMasterTagListWith(tasks);
    }

    /**
     * Removes an task from the task list using find task name method
     * @param key is of type ReadOnlyTask
     * @return boolean
     */
    public boolean removeFindTask(ReadOnlyTask key) throws TaskNotFoundException {
         if (completedTasks.contains(key)) {
             return completedTasks.remove(key);
         } else if (tasks.contains(key)) {
             return tasks.remove(key);
         } else {
             throw new TaskNotFoundException();
         }
    }

    /**
     * Removes an task from the active task list using find task index method
     * @param key is of type ReadOnlyTask
     * @return boolean
     */
    public boolean removeIndexActiveTask(ReadOnlyTask key) throws TaskNotFoundException {
        if (tasks.remove(key)){
            return true;
        } else {
            throw new TaskNotFoundException();
        }
    }

    /**
     * Removes an task from the complete task list using find task index method
     * @param key is of type ReadOnlyTask
     * @return boolean
     */
    public boolean removeIndexCompleteTask(ReadOnlyTask key) throws TaskNotFoundException {
                if (completedTasks.remove(key)){
            return true;
        } else {
            throw new TaskNotFoundException();
        }
    }

```
