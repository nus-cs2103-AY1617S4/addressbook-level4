# A0131884B
###### /java/seedu/ticktask/commons/core/Messages.java
``` java
    public static final String MESSAGE_INVALID_TASK_DISPLAYED = "No tasks to be found";
    public static final String MESSAGE_TASK_DESCRIPTION = "Description: ";
```
###### /java/seedu/ticktask/logic/commands/ClearCommand.java
``` java
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_SUCCESS = "The target list has been cleared!";
    public static final String MESSAGE_USAGE = COMMAND_WORD + " : Clear all tasks, active tasks or completed tasks.\n"
                                               + "Example: " + COMMAND_WORD + " all\n"
                                               + "Example: " + COMMAND_WORD + " active\n"
                                               + "Example: " + COMMAND_WORD + " complete\n";
    public static final String MESSAGE_NOT_SUCCESS = "The clear command should be either 'clear all' or 'clear active' or 'clear complete'.";
    private Prefix listIndicatorPrefix;

    /**
    * Creates an instance of a clear command object that clears the TickTask program.
    * @param listIndicatorPrefix referring to either the active, complete or both lists
    */
    public ClearCommand(Prefix listIndicatorPrefix) {
         this.listIndicatorPrefix = listIndicatorPrefix;
    }

    /**
     * Executes the clear command and returns the result message 
     *
     * @return feedback message of the operation result for display via a CommandResult Object
     * @throws CommandException If an error occurs during command execution.
     */
    @Override
    public CommandResult execute() throws CommandException {
        requireNonNull(model);
        if (listIndicatorPrefix.toString().equals(CliSyntax.PREFIX_ACTIVE.toString()))
        {
        	model.resetActiveData(new TickTask());
            return new CommandResult(MESSAGE_SUCCESS);
        }else if (listIndicatorPrefix.toString().equals(CliSyntax.PREFIX_COMPLETE.toString())) {
            model.resetCompleteData(new TickTask());
            return new CommandResult(MESSAGE_SUCCESS);
        }else if (listIndicatorPrefix.toString().equals(CliSyntax.PREFIX_ALL.toString())){
            model.resetData(new TickTask());
            return new CommandResult(MESSAGE_SUCCESS);
        }else {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED);
        }
    }
}
```
###### /java/seedu/ticktask/logic/commands/Command.java
``` java
    public abstract CommandResult execute() throws CommandException, IllegalValueException;
```
###### /java/seedu/ticktask/logic/commands/DeleteCommand.java
``` java
/*
 * Abstract class that that DeleteFindCommand and DeleteIndexCommand is instantiated from 
 */
public abstract class DeleteCommand extends Command {
    public static final String COMMAND_WORD = "delete";
    public static final String MESSAGE_USAGE = COMMAND_WORD + " : Delete the task identified by keywords"
                                               + " if it is the only task found, \nor delete the task "
                                               + "identified by the index number of the last"
                                               + " task list.\n" + "Format: " + COMMAND_WORD
                                               + " [task name]\n" + "Example: " + COMMAND_WORD
                                               + " wash clothes\n"
                                               + "or " + COMMAND_WORD + " " + PREFIX_ACTIVE
                                               + " INDEX (must be a positive integer)"
                                               + " or " + COMMAND_WORD + " " + PREFIX_COMPLETE
                                               + " INDEX (must be a positive integer)\n"
                                               + "Example: " + COMMAND_WORD + " "
                                               + PREFIX_COMPLETE + " 1";
    public static final String MESSAGE_SUCCESS = "Task deleted:" + "\n"
            + Messages.MESSAGE_TASK_DESCRIPTION + "%1$s";
    public static final String MESSAGE_WARNING = "The deleted task name is a subset of the stored task name.\n"
                                                 + "Please use 'undo' command to restore if "
                                                 + "the deletion in not desired.\n"
                                                 + "Task deleted:" + "\n"
                                                 + Messages.MESSAGE_TASK_DESCRIPTION + "%1$s";
    protected ReadOnlyTask taskToDelete;
}
```
###### /java/seedu/ticktask/logic/commands/DeleteFindCommand.java
``` java
/**
 * Finds tasks from given task name and deletes task if it is the only one found.
 * If it is not the only one, delete by index then.
 */
public class DeleteFindCommand extends DeleteCommand {
    public static final String MESSAGE_NO_TASKS = "No tasks found! Please try again "
                                                  + "with different keywords. \nUse 'list' command to go back";

    public static final String MESSAGE_MULTIPLE_TASKS = "More than one task found! \n"
                                                        + "Use " + COMMAND_WORD + " [ "
                                                        + PREFIX_COMPLETE + " ]" + " or " + COMMAND_WORD + " [ "
                                                        + PREFIX_ACTIVE + " ]"
                                                        + " INDEX to specify which task to delete. \n"
                                                        + "Use 'list' command to go back after finishing deletion.";

    private String keywords;

    public DeleteFindCommand(String keywords) {
        this.keywords = keywords;
    }

    /** Executes the delete by find command and returns the result message
     * @return feedback message of the operation result for display via a CommandResult Object.
     * @throws DuplicateTaskException if more than one task with the same name substring is found
     */
    @Override
    public CommandResult execute() throws CommandException, DuplicateTaskException {
        model.updateMatchedTaskList(keywords);
        List<ReadOnlyTask> tempList = new ArrayList<>();
        tempList.addAll(model.getFilteredActiveTaskList());
        tempList.addAll(model.getFilteredCompletedTaskList());
        
        if (tempList.size() == 1) {
            taskToDelete = tempList.get(0);
            try {
                model.deleteFindTask(taskToDelete);
            } catch (TaskNotFoundException e) {
                assert false : "The target task cannot be missing";
            }
            model.updateFilteredListToShowAll();
            if (keywords.equals(taskToDelete.getName().fullName)) {
                return new CommandResult(String.format(MESSAGE_SUCCESS, taskToDelete));
            } else {
                return new CommandResult(String.format(MESSAGE_WARNING, taskToDelete));
            }
        } else {
            if (tempList.size() >= 2) {
                return new CommandResult(MESSAGE_MULTIPLE_TASKS);
            } else {
                assert (tempList.size() == 0);
                return new CommandResult(MESSAGE_NO_TASKS);
            }
        }
    }
}


```
###### /java/seedu/ticktask/logic/commands/DeleteIndexCommand.java
``` java
/**
 * Deletes an task identified using the type of task followed by task index.
 */
public class DeleteIndexCommand extends DeleteCommand {
    private Index targetIndex;
    private Prefix listIndicatorPrefix;

    public DeleteIndexCommand(Index targetIndex, Prefix listIndicatorPrefix) {
        this.targetIndex = targetIndex;
        this.listIndicatorPrefix = listIndicatorPrefix;
    }
    
    /**
     * Executes the delete by index command and returns the result message.
     *
     * @return feedback message of the operation result for display via a CommandResult Object
     * @throws CommandException if the given index is invalid
     * @throws DuplicateTaskException if more than one task with the same name substring is found
     */

    @Override
    public CommandResult execute() throws CommandException , DuplicateTaskException {
        UnmodifiableObservableList<ReadOnlyTask> listToDeleteFrom;
        assert listIndicatorPrefix != null;
        if (listIndicatorPrefix.equals(PREFIX_ACTIVE)) {
            listToDeleteFrom = model.getFilteredActiveTaskList();
        } else {
            assert listIndicatorPrefix.equals(PREFIX_COMPLETE);
            listToDeleteFrom = model.getFilteredCompletedTaskList();
        }

        if (targetIndex.getZeroBased() >= listToDeleteFrom.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        taskToDelete = listToDeleteFrom.get(targetIndex.getZeroBased());
        try {
            if (listIndicatorPrefix.equals(PREFIX_COMPLETE))
                model.deleteIndexCompleteTask(taskToDelete);
            else
                model.deleteIndexActiveTask(taskToDelete);
        } catch (TaskNotFoundException enfe) {
            assert false : "The target list cannot be missing";
        }

        return new CommandResult(String.format(MESSAGE_SUCCESS, taskToDelete));
    }

}
```
###### /java/seedu/ticktask/logic/commands/HelpCommand.java
``` java
/**
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = "help";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Shows program usage instructions.\n"
                                               + "Example: " + COMMAND_WORD;

    public static final String SHOWING_HELP_MESSAGE = "Please add command keyword after help.\n"
                                                      + "The basic command words are as follows:\n"
                                                      + "add, clear, complete, delete, edit, exit, find, history, "
                                                      + "list, redo, restore, save, select and undo.\n"
                                                      + "Example: help add";

    private String usageMessage;
    /**
     * Create a HelpCommand object with help message for a command
     * @param helpMessage The message for usage of a specific command
     */
    public HelpCommand(String helpMessage) {
        super();
        usageMessage = helpMessage;
    }

    /**
     * Create a HelpCommand object with no specific help message
     */
    public HelpCommand() {
        super();
    }

    @Override
    public CommandResult execute() {
        if (usageMessage == null) {
            return new CommandResult(SHOWING_HELP_MESSAGE);
        } else {
            return new CommandResult(usageMessage);
        }
    }
}
```
###### /java/seedu/ticktask/logic/commands/ListCommand.java
``` java
                if (checkEmpty()) {
                    return new CommandResult(MESSAGE_EMPTY_TASK_LIST);
                } else {
                    return new CommandResult(MESSAGE_SUCCESS_VIEW_ALL_TASKS);
                }
```
###### /java/seedu/ticktask/logic/commands/ListCommand.java
``` java
    /**
     * return true is the target list is empty
     */
        boolean checkEmpty() {
            List<ReadOnlyTask> tempList = new ArrayList<>();
            tempList.addAll(model.getFilteredActiveTaskList());
            tempList.addAll(model.getFilteredCompletedTaskList());

            if (tempList.size() == 0) {
                return true;
            } else {
                return false;
            }
        }
```
###### /java/seedu/ticktask/logic/parser/ClearCommandParser.java
``` java
/**
 * Parses input arguments and creates a new Clear Command object
 */
public class ClearCommandParser {

    private ArgumentMultimap argMultimap;

        public ArgumentMultimap getArgMultimapClear() {
                return argMultimap;
            }
        
        /**
         * Parses the given {@code String} of arguments in the context of the ClearCommand and returns an
         * ClearCommand object for execution.
         * @param args containing keywords by user indicating list to clear: 'clear all', 'clear complete', or 'clear active'
         * @throws ParseException if the user input does not conform the expected format
         */
        public ClearCommand parse(String args) throws ParseException, IllegalValueException {
            argMultimap = ArgumentTokenizer.tokenize(args, CliSyntax.PREFIX_COMPLETE, CliSyntax.PREFIX_ACTIVE, CliSyntax.PREFIX_ALL);

            if (!isValid(args.trim())){
                throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                        ClearCommand.MESSAGE_USAGE));
            }

            Prefix listIndicatorPrefix = ParserUtil.getListPrefix(argMultimap,  CliSyntax.PREFIX_COMPLETE, CliSyntax.PREFIX_ACTIVE, CliSyntax.PREFIX_ALL);
			return new ClearCommand(listIndicatorPrefix);

        }   
            

        /**
         * @param listType string representing the list the user intends to clear
         * @return true only if the listtpye string after the "clear" keyword is: "all", "active" or "complete".
         */
        private boolean isValid(String listType) {
            if(listType.equals(CliSyntax.PREFIX_ALL.toString()) || listType.equals(CliSyntax.PREFIX_ACTIVE.toString()) || listType.equals(CliSyntax.PREFIX_COMPLETE.toString())){
                return true;
            }
            return false;

        }
}
```
###### /java/seedu/ticktask/logic/parser/CliSyntax.java
``` java
    public static final Prefix PREFIX_COMPLETE = new Prefix("complete");
    public static final Prefix PREFIX_ACTIVE = new Prefix("active");
    public static final Prefix PREFIX_ALL = new Prefix("all");
```
###### /java/seedu/ticktask/logic/parser/DeleteCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser {

    private ArgumentMultimap argMultimap;

        public ArgumentMultimap getArgMultimapDelete() {
                return argMultimap;
            }

    /**
    * Parses the given {@code String} of arguments in the context of the DeleteCommand and returns an
    * DeleteCommand object for execution.
    * @throws ParseException if the user input does not conform the expected format
    */
    public DeleteCommand parse(String args) throws ParseException {
                argMultimap = ArgumentTokenizer.tokenize(args, PREFIX_COMPLETE, PREFIX_ACTIVE);
        if (args.trim().isEmpty()) {
                throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                DeleteCommand.MESSAGE_USAGE));
         }

        /**
        * delete by index
        */
        if (hasIndexFlag(argMultimap)) {
        	if (hasInvalidPrefixCombination(argMultimap)) {
                throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                                       DeleteCommand.MESSAGE_USAGE));
        	}
            try {
                Prefix listIndicatorPrefix = ParserUtil.getListPrefix(argMultimap,  PREFIX_COMPLETE, PREFIX_ACTIVE);
                Index index = ParserUtil.parseIndex(argMultimap.getValue(listIndicatorPrefix).get());
                return new DeleteIndexCommand(index, listIndicatorPrefix);
            } catch (IllegalValueException ive) {
                throw new ParseException(ive.getMessage(), ive);
            }
        /**
        * delete by task name
        */
        } else {
            String trimmedArgs = argMultimap.getPreamble();
            return new DeleteFindCommand(trimmedArgs);
        }
    }

    /**
    * A method that returns true if flags are given in an illogical manner for deleting commands.
    * illogical := any 2 of /float, /deadline, /event used together.
    */
    private boolean hasInvalidPrefixCombination(ArgumentMultimap argMultimap) {
            assert argMultimap != null;
            return ParserUtil.areAllPrefixesPresent(argMultimap, PREFIX_ACTIVE, PREFIX_COMPLETE);                  
        }
    /**
    * A method that returns true if flags in given ArgumentMultimap has at least one index-indicating
    * Prefix mapped to some arguments.
    * Index-indicating : /active or /complete
    */
    private boolean hasIndexFlag(ArgumentMultimap argMultimap) {
        assert argMultimap != null;
        return ParserUtil.isPrefixPresent(argMultimap,  PREFIX_COMPLETE, PREFIX_ACTIVE);
    }
}



```
###### /java/seedu/ticktask/logic/parser/ParseHelpCommand.java
``` java
/**
 * Parses input arguments and creates a new HelpCommand object.
 */
public class ParseHelpCommand {
    /**
     * Parses the given {String} of arguments in the context of the HelpCommand.
     * and returns a HelpCommand object for execution.
     * @param args The string after the command word help.
     */
    public HelpCommand parse(String args) {
        if (args == null) {
            return new HelpCommand();
        }
        
        final String commandWord = args.trim();
        final String helpMessage = parseCommand(commandWord);
        if (helpMessage == null) {
            return new HelpCommand();
        } else {
            return new HelpCommand(helpMessage);
        }
    }
    /**
     * Check for the command word in the given {String} of command
     * and returns the help message of the corresponding command.
     * @param commandWord A string which may be the command word.
     */
    private static String parseCommand(String commandWord) {
        switch (commandWord) {
            case AddCommand.COMMAND_WORD:
                return AddCommand.MESSAGE_USAGE;

            case ClearCommand.COMMAND_WORD:
                return ClearCommand.MESSAGE_USAGE;

            case CompleteCommand.COMMAND_WORD:
                return CompleteCommand.MESSAGE_USAGE;

            case DeleteCommand.COMMAND_WORD:
                return DeleteCommand.MESSAGE_USAGE;

            case EditCommand.COMMAND_WORD:
                return EditCommand.MESSAGE_USAGE;

            case ExitCommand.COMMAND_WORD:
                return ExitCommand.MESSAGE_USAGE;

            case FindCommand.COMMAND_WORD:
                return FindCommand.MESSAGE_USAGE;

            case HelpCommand.COMMAND_WORD:
                return HelpCommand.MESSAGE_USAGE;

            case HistoryCommand.COMMAND_WORD:
                return HistoryCommand.MESSAGE_USAGE;

            case ListCommand.COMMAND_WORD:
                return ListCommand.MESSAGE_USAGE;

            case RedoCommand.COMMAND_WORD:
                return RedoCommand.MESSAGE_USAGE;

            case RestoreCommand.COMMAND_WORD:
                return RestoreCommand.MESSAGE_USAGE;

            case SelectCommand.COMMAND_WORD:
                return SelectCommand.MESSAGE_USAGE;

            case StorageCommand.COMMAND_WORD:
                return StorageCommand.MESSAGE_USAGE;

            case UndoCommand.COMMAND_WORD:
                return UndoCommand.MESSAGE_USAGE;

            default:
                return null;
        }
    }
}
```
###### /java/seedu/ticktask/logic/parser/Parser.java
``` java
        case DeleteCommand.COMMAND_WORD:
            return new DeleteCommandParser().parse(arguments);
```
###### /java/seedu/ticktask/logic/parser/Parser.java
``` java
        case HelpCommand.COMMAND_WORD:
            return new ParseHelpCommand().parse(arguments);
```
###### /java/seedu/ticktask/logic/parser/ParserUtil.java
``` java
   /**
    * Return prefix that has arguments mapped to it, and remove prefixes that are not mapped to anything in argMultimap
    */
    public static Prefix getListPrefix(ArgumentMultimap argMultimap, Prefix... prefixes) {
         List<Prefix> temp = Stream.of(prefixes).filter(prefix -> argMultimap.getValue(prefix).isPresent()).collect(Collectors.toList());
            assert (temp.size() <= 1) : "invalid flag combination not catched beforehand or no Prefixes found!";
            return temp.get(0);
    }

   /**
    * Returns true if any of the prefixes contain non-empty values in argMultimap
    */
    public static boolean isPrefixPresent(ArgumentMultimap argumentMultimap, Prefix... prefixes) {
         return Stream.of(prefixes).anyMatch(prefix -> argumentMultimap.getValue(prefix).isPresent());
    }
    
    /**
     * Returns true if none of the prefixes contains empty {@code Optional} values in the given
     * {@code ArgumentMultimap}.
     */
    public static boolean areAllPrefixesPresent(ArgumentMultimap argumentMultimap, Prefix... prefixes) {
        return Stream.of(prefixes).allMatch(prefix -> argumentMultimap.getValue(prefix).isPresent());
    }
    
    /**
     * Remove Prefix's not mapped to anything in ArgumentMultimap parameter, and returns prefix that has
     * arguments mapped to it. This means the mapping should be a one-one mapping.
     */
    public static Prefix getPrefix(ArgumentMultimap argMultimap, Prefix... prefixes) {
        List<Prefix> tempList = Stream.of(prefixes).filter(prefix -> argMultimap.getValue(prefix).isPresent())
                                  .collect(Collectors.toList());
        if (tempList.size() != 1) {
            assert false : "More than one or zero Prefixes is found";
        }
        return tempList.get(0);
    }
```
###### /java/seedu/ticktask/model/Model.java
``` java
    /** Deletes the given task using find task name method. */
    void deleteFindTask(ReadOnlyTask target) throws TaskNotFoundException, DuplicateTaskException;

    /** Deletes the given complete task using find task index method. */
    void deleteIndexCompleteTask(ReadOnlyTask target) throws TaskNotFoundException, DuplicateTaskException;

    /** Deletes the given active task using find task index method. */
    void deleteIndexActiveTask(ReadOnlyTask target) throws TaskNotFoundException, DuplicateTaskException;

    /** Clear active list. */
    void resetActiveData(ReadOnlyTickTask newData);

    /** clear complete list. */
    void resetCompleteData(ReadOnlyTickTask newData);
```
###### /java/seedu/ticktask/model/Model.java
``` java
    /* Updates the filter of the filtered task list if and only if it contain all of the given keywords*/
    void updateMatchedTaskList(String keywords);
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java

    @Override
    /**Deletes the given task using find task name method.
     */
    public synchronized void deleteFindTask(ReadOnlyTask target) throws TaskNotFoundException, DuplicateTaskException {
        saveInstance();
        currentProgramInstance.removeFindTask(target);
        indicateTickTaskModelChanged();
    }
    /**Deletes the given active task using find task index method
    */
    public synchronized void deleteIndexActiveTask(ReadOnlyTask target) throws TaskNotFoundException, DuplicateTaskException {
        saveInstance();
        currentProgramInstance.removeIndexActiveTask(target);
        indicateTickTaskModelChanged();
    }

    public synchronized void deleteIndexCompleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        saveInstance();
        currentProgramInstance.removeIndexCompleteTask(target);
        indicateTickTaskModelChanged();
    }

    @Override
    public void resetActiveData(ReadOnlyTickTask newData) {
        saveInstance();
        currentProgramInstance.resetActiveData(newData);
        indicateTickTaskModelChanged();
    }

    @Override
    public void resetCompleteData(ReadOnlyTickTask newData) {
        saveInstance();
        currentProgramInstance.resetCompleteData(newData);
        indicateTickTaskModelChanged();
    }
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java
    @Override
    public void updateMatchedTaskList(String keywords) {
        updateMatchedTaskList(new PredicateExpression(new newNameQualifier(keywords)));

    }

    private void updateMatchedTaskList(Expression expression) {
        filteredActiveTasks.setPredicate(expression::satisfies);
        filteredCompletedTasks.setPredicate(expression::satisfies);
    }
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java
        // state check
        ModelManager other = (ModelManager) obj;
        return currentProgramInstance.equals(other.currentProgramInstance)
                && filteredActiveTasks.equals(other.filteredActiveTasks)
                                && filteredCompletedTasks.equals(other.filteredCompletedTasks);
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java
    private class newNameQualifier implements Qualifier {
        private String nameKeyWord;


        newNameQualifier(String nameKeyWord) {
            this.nameKeyWord = nameKeyWord;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            String taskName = task.getName().fullName;
            return taskName.toLowerCase().contains(nameKeyWord.toLowerCase());
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWord);
        }
    }
```
###### /java/seedu/ticktask/model/TickTask.java
``` java
   /**
    * Clear complete list
    * @param completedTasks is of type ReadOnlyTask
    * @return boolean
    */

    public void setCompleteData(List<? extends ReadOnlyTask> completedTasks) throws DuplicateTaskException {
        this.completedTasks.setTasks(completedTasks);
    }

    /**
     * Clear active list
     * @param tasks is of type ReadOnlyTask
     * @return boolean
     */
    public void setActiveData(List<? extends ReadOnlyTask> tasks) throws DuplicateTaskException {
        this.tasks.setTasks(tasks);
    }

    /**
     * Mark complete list to be cleared
     * @param newData is of type ReadOnlyTickTask
     * @return boolean
     */
    public void resetCompleteData(ReadOnlyTickTask newData) {
        requireNonNull(newData);
        try {
            setCompleteData(newData.getCompletedTaskList());
        } catch (DuplicateTaskException e) {
            assert false : "The TickTask program should not have duplicate tasks";
        }
        try {
            setTags(newData.getTagList());
        } catch (UniqueTagList.DuplicateTagException e) {
            assert false : "The TickTask program should not have duplicate tags";
        }
        syncMasterTagListWith(tasks);
    }

    /**
     * Mark active list to be cleared
     * @param newData is of type ReadOnlyTickTask
     * @return boolean
     */
    public void resetActiveData(ReadOnlyTickTask newData) {
        requireNonNull(newData);
        try {
            setActiveData(newData.getActiveTaskList());
        } catch (DuplicateTaskException e) {
            assert false : "The TickTask program should not have duplicate tasks";
        }
        try {
            setTags(newData.getTagList());
        } catch (UniqueTagList.DuplicateTagException e) {
            assert false : "The TickTask program should not have duplicate tags";
        }
        syncMasterTagListWith(tasks);
    }

    /**
     * Removes an task from the task list using find task name method
     * @param key is of type ReadOnlyTask
     * @return boolean
     */
    public boolean removeFindTask(ReadOnlyTask key) throws TaskNotFoundException {
         if (completedTasks.contains(key)) {
             return completedTasks.remove(key);
         } else if (tasks.contains(key)) {
             return tasks.remove(key);
         } else {
             throw new TaskNotFoundException();
         }
    }

    /**
     * Removes an task from the active task list using find task index method
     * @param key is of type ReadOnlyTask
     * @return boolean
     */
    public boolean removeIndexActiveTask(ReadOnlyTask key) throws TaskNotFoundException {
        if (tasks.remove(key)){
            return true;
        } else {
            throw new TaskNotFoundException();
        }
    }

    /**
     * Removes an task from the complete task list using find task index method
     * @param key is of type ReadOnlyTask
     * @return boolean
     */
    public boolean removeIndexCompleteTask(ReadOnlyTask key) throws TaskNotFoundException {
                if (completedTasks.remove(key)){
            return true;
        } else {
            throw new TaskNotFoundException();
        }
    }

```
