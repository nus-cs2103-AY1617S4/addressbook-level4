# A0138471A
###### /java/seedu/ticktask/commons/core/Config.java
``` java
    public String getTickTaskFilePath() {
        return tickTaskFilePath;
    }

    public void setTickTaskFilePath(String tickTaskFilePath) throws DuplicateTickTaskFilePathException {
        this.tickTaskFilePath = tickTaskFilePath;
    }

    public static class DuplicateTickTaskFilePathException extends DuplicateDataException {
        protected DuplicateTickTaskFilePathException() {
            super("Duplicate File Path");
        }
    }
```
###### /java/seedu/ticktask/logic/commands/ListCommand.java
``` java
/**
 * Lists all tasks in the TickTask to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    public static final String LIST_ALL = "";
    public static final String LIST_ALL_FULL = "all";
    public static final String LIST_EVENT = "event";
    public static final String LIST_DEADLINE = "deadline";
    public static final String LIST_FLOATING = "floating";
    public static final String LIST_TODAY = "today";

    public static final String MESSAGE_EMPTY_TASK_LIST = "No task is found";
    public static final String MESSAGE_SUCCESS_VIEW_ALL_TASKS = "Listed all tasks";
    public static final String MESSAGE_SUCCESS_VIEW_EVENT_TASKS = "List all Event Tasks";
    public static final String MESSAGE_SUCCESS_VIEW_DEADLINE_TASKS = "List all Deadline Tasks";
    public static final String MESSAGE_SUCCESS_VIEW_FLOATING_TASKS = "List all Floating Tasks";
    public static final String MESSAGE_SUCCESS_VIEW_TODAY_TASKS = "List all Today's Tasks";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": List a type of specified tasks.\n"
            + "The task types are as follows: event, deadline, floating, today and all.\n"
            + "Example: " + COMMAND_WORD + " " + LIST_DEADLINE;

    private static ArrayList<String> list_command_array = new ArrayList<String>(Arrays.asList(
            LIST_ALL, LIST_ALL_FULL, LIST_EVENT, LIST_EVENT, LIST_DEADLINE, LIST_FLOATING, LIST_TODAY));
    
    private String listCommandType;

    public ListCommand(String list) {
        this.listCommandType = list;
    }

    public static boolean isValidCommand(String command) {
        return list_command_array.contains(command);
    }

    @Override
    public CommandResult execute() {

        switch (listCommandType) {
            case LIST_ALL:
            case LIST_ALL_FULL:
                model.updateFilteredListToShowAll();
```
###### /java/seedu/ticktask/logic/commands/ListCommand.java
``` java
            case LIST_EVENT:
                model.updateFilteredListToShowEvent();
                if (checkEmpty()) {
                    return new CommandResult(MESSAGE_EMPTY_TASK_LIST);
                } else {
                    return new CommandResult(MESSAGE_SUCCESS_VIEW_EVENT_TASKS);
                }
            case LIST_DEADLINE:
                model.updateFilteredListToShowDeadline();
                if (checkEmpty()) {
                    return new CommandResult(MESSAGE_EMPTY_TASK_LIST);
                } else {
                    return new CommandResult(MESSAGE_SUCCESS_VIEW_DEADLINE_TASKS);
                }
            case LIST_FLOATING:
                model.updateFilteredListToShowFloating();
                if (checkEmpty()) {
                    return new CommandResult(MESSAGE_EMPTY_TASK_LIST);
                } else {
                    return new CommandResult(MESSAGE_SUCCESS_VIEW_FLOATING_TASKS);
                }
            case LIST_TODAY:
                model.updateFilteredListToShowToday();
                if (checkEmpty()) {
                    return new CommandResult(MESSAGE_EMPTY_TASK_LIST);
                } else {
                    return new CommandResult(MESSAGE_SUCCESS_VIEW_TODAY_TASKS);
                }
            default:
                model.updateFilteredListToShowAll();
                if (checkEmpty()) {
                    return new CommandResult(MESSAGE_EMPTY_TASK_LIST);
                } else {
                    return new CommandResult(MESSAGE_SUCCESS_VIEW_ALL_TASKS);
                }
        }
    }
```
###### /java/seedu/ticktask/logic/commands/StorageCommand.java
``` java
/**
 * Changes the location where the TickTask file is saved.
 */

public class StorageCommand extends Command {

    public static final String COMMAND_WORD = "save";

    public static final String MESSAGE_SUCCESS = "Location changed to: %1$s";
    public static final String MESSAGE_DUPLICATE_TICK_TASK_FILE_PATH = "File is already saved at this location";
    public static final String MESSAGE_CREATED_NEW_CONFIG_FILE = "IO";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Changes the location of the Tick Task app doc.\n"
            + "Example: " + COMMAND_WORD + " doc";

    private final File file;

    public StorageCommand(File location) {
        this.file = location;
    }

    @Override
    public CommandResult execute() throws CommandException {

        try {

            Config config = new Config();
            config.setTickTaskFilePath(file.toString());
            ConfigUtil.saveConfig(config, Config.DEFAULT_CONFIG_FILE);
            XmlTickTaskStorage.setTickTaskFilePath(file.toString());
            model.saveTickTask();
            return new CommandResult(String.format(MESSAGE_SUCCESS, file));

        } catch (Config.DuplicateTickTaskFilePathException dtmfpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TICK_TASK_FILE_PATH);
        } catch (IOException ioe) {
            throw new CommandException(MESSAGE_CREATED_NEW_CONFIG_FILE);
        }
    }   
}

```
###### /java/seedu/ticktask/logic/parser/ListCommandParser.java
``` java
/**
 * Parses input arguments for ListCommand Object
 */
public class ListCommandParser {
	
    /**
     * Parses the given {@code String} of arguments in the context of the ListCommand
     * and returns an ListCommand object for execution.
     */
	public Command parse(String args) throws ParseException {
        String typeOfList = args.trim().toLowerCase();

        if (!ListCommand.isValidCommand(typeOfList)) {
        	throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
            
        }

        return new ListCommand(typeOfList);
    }

}
```
###### /java/seedu/ticktask/logic/parser/Parser.java
``` java
        case ListCommand.COMMAND_WORD:
        	return new ListCommandParser().parse(arguments);
        	
        case StorageCommand.COMMAND_WORD:
            return new StorageCommandParser().parse(arguments);
```
###### /java/seedu/ticktask/logic/parser/StorageCommandParser.java
``` java
/**
 * Parses input arguments for ListCommand Object
 */
public class StorageCommandParser {

	public static final String MESSAGE_INVALID_LOCATION = "Location does not exist!";
    /**
     * Parses the given {@code String} of arguments in the context of the StorageCommand
     * and returns an StorageCommand object for execution.
     */
	public Command parse(String args) throws ParseException {

		String stringLocation = args;
		File trimmedLocation = new File(args.trim());

		if (("".equals(stringLocation))) {
			throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, StorageCommand.MESSAGE_USAGE));

		}

		if (!trimmedLocation.exists()) {
			throw new ParseException(String.format(MESSAGE_INVALID_LOCATION, StorageCommand.MESSAGE_USAGE));
		}

		if (!(stringLocation.substring(stringLocation.length() - 1).equals("/"))) {
			stringLocation += "/";
		}
		
		stringLocation += "ticktask.xml";
		File location = new File(stringLocation.trim());

		return new StorageCommand(location);
	}
}
```
###### /java/seedu/ticktask/model/Model.java
``` java
    /** Updates the filter of the filtered task list to show all event tasks*/
    void updateFilteredListToShowEvent();
    
    /** Updates the filter of the filtered task list to show all deadline tasks*/
    void updateFilteredListToShowDeadline();
    
    /** Updates the filter of the filtered task list to show all floating tasks*/
    void updateFilteredListToShowFloating();
    
    /** Updates the filter of the filtered task list to show all today's tasks*/
    void updateFilteredListToShowToday();
    
    public void saveTickTask();
```
###### /java/seedu/ticktask/model/ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowEvent() {

        filteredActiveTasks.setPredicate((Predicate<? super ReadOnlyTask>) task -> {
            return task.getTaskType().toString().equals("event");
        });
        filteredCompletedTasks.setPredicate((Predicate<? super ReadOnlyTask>) task -> {
            return task.getTaskType().toString().equals("event");
        });

    }
    
    @Override
    public void updateFilteredListToShowDeadline() {

        filteredActiveTasks.setPredicate((Predicate<? super ReadOnlyTask>) task -> {
            return task.getTaskType().toString().equals("deadline");
        });
        filteredCompletedTasks.setPredicate((Predicate<? super ReadOnlyTask>) task -> {
            return task.getTaskType().toString().equals("deadline");
        });

    }
    
    @Override
    public void updateFilteredListToShowFloating() {

        filteredActiveTasks.setPredicate((Predicate<? super ReadOnlyTask>) task -> {
            return task.getTaskType().toString().equals("floating");
        });
        filteredCompletedTasks.setPredicate((Predicate<? super ReadOnlyTask>) task -> {
            return task.getTaskType().toString().equals("floating");
        });

    }
    
    @Override
    public void updateFilteredListToShowToday() {

        filteredActiveTasks.setPredicate((Predicate<? super ReadOnlyTask>) task -> {
            return ((task.getDate().getEndDate().equals(LocalDate.now().format(DATE_FORMAT).toString())) || 
            		(task.getDate().getStartDate().equals(LocalDate.now().format(DATE_FORMAT).toString())));
        });
        filteredCompletedTasks.setPredicate((Predicate<? super ReadOnlyTask>) task -> {
            return ((task.getDate().getEndDate().equals(LocalDate.now().format(DATE_FORMAT).toString())) || 
            		(task.getDate().getStartDate().equals(LocalDate.now().format(DATE_FORMAT).toString())));
        });

    }
    
    @Override
    public void saveTickTask(){
    	indicateTickTaskModelChanged();
    }
```
###### /java/seedu/ticktask/model/task/DueDate.java
``` java
/**
 * Represents a Task's date in the TickTask.
 * Guarantees: immutable; is valid as declared in {@link #isValidDate(String)}
 */

public class DueDate {

    public static final String MESSAGE_DATE_CONSTRAINTS = "Enter a valid date";
    public static final String START_DATE_VALIDATION_REGEX = "start date.*";
    public static final String END_DATE_VALIDATION_REGEX = "end date.*";
    public static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile(START_DATE_VALIDATION_REGEX);
    private static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern("MM/dd/uuuu");
    private static final int FIRST_INDEX_OF_ARRAY = 0;
    private static final int INDEX_START_DATE = 0;
    private static final int INDEX_END_DATE = 1;
```
###### /java/seedu/ticktask/model/task/DueDate.java
``` java
    private final Parser parser = new Parser();
    private String value;
    private LocalDate local_date;
    private ArrayList<LocalDate> datesArray = new ArrayList<LocalDate>();
    private LocalDate start_date;
    private LocalDate end_date;
    private String start_date_string = "";
    private String end_date_string = "";
    private boolean isFloating = false;
    private boolean isRange = false;
    private boolean isDeadline = false;
    
    /**
     * Validates given due date.
     *
     * @throws IllegalValueException if given date string is invalid.
     */
    public DueDate(String date) throws IllegalValueException {
        requireNonNull(date);

        String trimmedDate = date.trim();
        
          
        if (((date.matches(END_DATE_VALIDATION_REGEX)) || (date.matches(START_DATE_VALIDATION_REGEX)))) {
            List<DateGroup> dateGroups = parser.parse(trimmedDate);

            if (!dateGroups.isEmpty()) {
                for (Date dates : dateGroups.get(FIRST_INDEX_OF_ARRAY).getDates()) {
                    local_date = Instant.ofEpochMilli(dates.getTime()).atZone(ZoneId.systemDefault()).toLocalDate();
                    datesArray.add(local_date);
                }
            }
            if (date.matches(END_DATE_VALIDATION_REGEX)) {
                end_date = datesArray.get(INDEX_START_DATE);
                setEndDate(end_date);
            }
            if (date.matches(START_DATE_VALIDATION_REGEX)) {
                start_date = datesArray.get(INDEX_START_DATE);
                setStartDate(start_date);
            }

        } else {
            extractDate(trimmedDate);
        }

        if (end_date != null){
            value = getStartDate() + " - " + getEndDate();
        } else {
            value = getStartDate();
        }

    }

    /**
     * Extracts date into start date and end date.
     */
    void extractDate(String trimmedDate) {
        List<DateGroup> dateGroups = parser.parse(trimmedDate);

        if (!dateGroups.isEmpty()) {
            for (Date dates : dateGroups.get(FIRST_INDEX_OF_ARRAY).getDates()) {
                local_date = Instant.ofEpochMilli(dates.getTime()).atZone(ZoneId.systemDefault()).toLocalDate();
                datesArray.add(local_date);
            }
        } else {
            setStartDate(null);
            setEndDate(null);
        }
        if (datesArray.size() == 2) {
            Collections.sort(datesArray);
            start_date = datesArray.get(INDEX_START_DATE);
            end_date = datesArray.get(INDEX_END_DATE);
            setStartDate(start_date);
            setEndDate(end_date);
            isRange = true;
            
        } else if (datesArray.size() == 1) {
            start_date = datesArray.get(INDEX_START_DATE);
            setStartDate(start_date);
            setEndDate(null);
            isDeadline = true;

        } else {
            setStartDate(null);
            setEndDate(null);
            isFloating = true;
        }

    }
    
    /**
     * Sets value
     */
    public String getValue() {
        return value;
    }

    /**
     * returns value
     */
    public void setValue(String value) {
        this.value = value;
    }

    /**
     * Sets end date in the LocalDate form
     */
    public void setEndDate(LocalDate end_date2) {
        if (end_date2 == null) {
            end_date_string =  "";
            end_date = end_date2;
            value = getStartDate();

        } else {
            end_date_string = end_date2.format(DATE_FORMAT).toString();
            end_date = end_date2;
            if (end_date != null) {
                value = getStartDate() + " - " + getEndDate();
            } else {
                value = getStartDate();
            }
        }
    }

    /**
     * Sets start date in the LocalDate form
     */
    public void setStartDate(LocalDate start_date2) {
        if (start_date2 == null) {
            start_date_string =  "";
            start_date = start_date2;
            value = getStartDate();

        } else {
            start_date_string = start_date2.format(DATE_FORMAT).toString();
            start_date = start_date2;
            if (end_date != null){
                value = getStartDate() + " - " + getEndDate();
            } else {
                value = getStartDate();
            }
        }

    }

    /**
     * Returns end date in String
     */
    public String getEndDate() {

        return end_date_string;
    }
    
    /**
     * Returns start date in String
     */
    public String getStartDate() {
        
        return start_date_string;
    }
    
    /**
     * Returns start date in LocalDate form
     */
    public LocalDate getLocalStartDate() {
        return start_date;
    }
    
    /**
     * Returns end date in LocalDate form
     */
    public LocalDate getLocalEndDate() {
        return end_date;
    }

    /**
     * Returns true if a given date is an empty string or invalid string
     * */
    public boolean isFloating() {
        return isFloating;
    }
    
    /**
     * Sets the date to floating
     */
    public void setFloating(){
        isFloating = true;
        isDeadline = false;
        isRange = false;
    }
    
    /**
     * Returns true if a given date only has a start date
     */
    public boolean isDeadline() {
        return isDeadline;
    }

    /**
     * Sets the date to floating
     */
    public void setDeadline(){
        isFloating = false;
        isDeadline = true;
        isRange = false;
    }
    
    
    /**
     * Returns true if a given date has both start and end date
     */
    public boolean isRange() {
        return isRange;
    }
    
    /**
     * Sets the date to range
     */
    public void setRange(){
        isFloating = false;
        isDeadline = false;
        isRange = true;
    }

    /**
     * Returns true if a given string is a valid date.
     */
    public static boolean isValidDate(String test) {
        return test.matches(START_DATE_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DueDate // instanceof handles nulls
                        && this.value.equals(((DueDate) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### /java/seedu/ticktask/model/task/DueTime.java
``` java
/**
 * Represents a task's deadline time.
 * Guarantees: immutable; is valid as declared in {@link #isValidTime(String)}
 */
public class DueTime {

    public static final String MESSAGE_TIME_CONSTRAINTS = "Time is not a valid time";
    public static final String START_TIME_VALIDATION_REGEX = "start time.*";
    public static final String END_TIME_VALIDATION_REGEX = "end time.*";
    private static final String MESSAGE_END_TIME_CONSTRAINTS = "End time does not exist";
    private static final DateTimeFormatter TIME_FORMAT = DateTimeFormatter.ofPattern("HH:mm");
    private static final int FIRST_INDEX_OF_ARRAY = 0;
    private static final int INDEX_START_TIME = 0;
    private static final int INDEX_END_TIME = 1;
    private final Parser parser = new Parser();
    private String value;
    private LocalTime local_time;
    private ArrayList<LocalTime> timesArray = new ArrayList<LocalTime>();
    private LocalTime start_time;
    private LocalTime end_time;
    private String start_time_string = "";
    private String end_time_string = "";
    private boolean isFloating = false;
    private boolean isRange = false;
    private boolean isDeadline = false;

    /**
     * Validates given time.
     * @throws IllegalValueException if given time string is invalid.
     */
    public DueTime(String time) throws IllegalValueException {
        requireNonNull(time);
        String trimmedTime = time.trim();

        if (((time.matches(END_TIME_VALIDATION_REGEX)) || (time.matches(START_TIME_VALIDATION_REGEX)))) {
            List<DateGroup> dateGroups = parser.parse(time);

            if (!dateGroups.isEmpty()) {
                for (Date dates : dateGroups.get(FIRST_INDEX_OF_ARRAY).getDates()) {
                    local_time = Instant.ofEpochMilli(dates.getTime()).atZone(ZoneId.systemDefault()).toLocalTime();
                    timesArray.add(local_time);
                }
            }
            if (time.matches(END_TIME_VALIDATION_REGEX)) {
                end_time = timesArray.get(INDEX_START_TIME);
                setEndTime(end_time);
            }
            if (time.matches(START_TIME_VALIDATION_REGEX)) {
                start_time = timesArray.get(INDEX_START_TIME);
                setStartTime(start_time);
            }
        } else {
            extractTime(trimmedTime);
        }
        
        if (end_time != null){
            value = getStartTime() + " - " + getEndTime();
        } else {
            value = getStartTime();
        }
        
    }
    
    /**
     * sets end time
     */
    public void setEndTime(LocalTime end_time2) {
        if (end_time2 == null) {

            LocalTime localtime = LocalTime.MAX;
            end_time_string =  "";
            end_time = end_time2;
            value = getStartTime();

        }
        else {
            end_time_string = end_time2.format(TIME_FORMAT).toString();
            end_time = end_time2;
            if (end_time != null){
                value = getStartTime() + " - " + getEndTime();
            }else{
                value = getStartTime();
            }            

        }
    }
    
    /**
     * sets start time
     */
    public void setStartTime(LocalTime start_time2) {
        if (start_time2 == null) {

            start_time_string =  "";
            start_time = start_time2;
            value = getStartTime();
            
        } else {
            start_time_string = start_time2.format(TIME_FORMAT).toString();
            start_time = start_time2;
            if (end_time != null){
                value = getStartTime() + " - " + getEndTime();
            } else {
                value = getStartTime();
            }
        }
    }
    
    /**
      * Extracts date into start time and end time.
      */
    public void extractTime(String time) throws IllegalValueException {
        List<DateGroup> dateGroups = parser.parse(time);
 
        if (!dateGroups.isEmpty()) {
            for (Date dates : dateGroups.get(FIRST_INDEX_OF_ARRAY).getDates()) {
                local_time = Instant.ofEpochMilli(dates.getTime()).atZone(ZoneId.systemDefault()).toLocalTime();
                timesArray.add(local_time);
            }
        } else {
            setStartTime(null);
            setEndTime(null);
        }
        if (timesArray.size() == 2) {
            start_time = timesArray.get(INDEX_START_TIME);
            end_time = timesArray.get(INDEX_END_TIME);
            setStartTime(start_time);
            setEndTime(end_time);
            isRange = true;
        } else if (timesArray.size() == 1) {
            start_time = timesArray.get(INDEX_START_TIME);
            setStartTime(start_time);
            setEndTime(null);
            isDeadline = true;
        } else {
            setStartTime(null);
            setEndTime(null);
            isFloating = true;
        }


    }
    
    /**
      * sets value
      */
    public String getValue(){
        return value;
    }
        
    /**
      * returns value
      */
    public void setValue(String value) {
        this.value = value;
    }
    
    /**
      * gets end time
      */
    public String getEndTime() {

        return end_time_string;

    }
    
    /**
      * gets start time
      */
    public String getStartTime() {
        return start_time_string;
    }
    
    /**
      * gets local end time
      */
    public LocalTime getLocalEndTime() {
        return end_time;
    }
    
    /**
     * gets local start time
     */
    public LocalTime getLocalStartTime() {
        return start_time;
    }

    /**
     * Returns true if a given date is an empty string or invalid string
     */
    public boolean isFloating() {
        return isFloating;
    }
    
    /**
     * Sets the time to floating
     */
    public void setFloating() {
        isFloating = true;
        isDeadline = false;
        isRange = false;
    }

    /**
     * Returns true if a given date only has a start time
     */
    public boolean isDeadline() {
        return isDeadline;
    }
    
    /**
     * Sets the time to a deadline
     */
    public void setDeadline() {
        isFloating = false;
        isDeadline = true;
        isRange = false;
    }

    /**
     * Returns true if a given date has both start and end time
     */
    public boolean isRange() {
        return isRange;
    }

    /**
     * Toggles the time to a range type
     */
    public void setRange(){
        isFloating = false;
        isDeadline = false;
        isRange = true;
    }
    /**
     * Returns true if a given string is a valid time format.
     */
    public static boolean isValidTime(String test) {
        return test.matches(START_TIME_VALIDATION_REGEX);
    }

    @Override
    public String toString() {

        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DueTime
                        && this.value.equals(((DueTime) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### /java/seedu/ticktask/storage/XmlTickTaskStorage.java
``` java
    public static String newTickTaskFilePath(){
    	return filePath;
    }
    
    public static void setTickTaskFilePath(String newFilePath){
    	filePath = newFilePath;
    }
```
###### /java/seedu/ticktask/ui/StatusBarFooter.java
``` java

        setSaveLocation(XmlTickTaskStorage.newTickTaskFilePath());
```
###### /java/seedu/ticktask/ui/TaskCard.java
``` java
    private static final String FXML = "TaskListCard.fxml";
    private static final String TICK = "/images/TICK.png";
    private static final String NO_TICK = "/images/Transparent_Background.png";
```
###### /java/seedu/ticktask/ui/TaskCard.java
``` java
        Image tick = new Image(TICK);
        Image no_tick = new Image(NO_TICK);
        if(task.getCompleted()){
            ticksymbol.setFill(new ImagePattern(tick));
        }
        else{
            ticksymbol.setFill(new ImagePattern(no_tick));
        }
```
###### /java/seedu/ticktask/ui/TaskCard.java
``` java
    /**
     * Change the color of the text to red when the event has already passed
     */
    private void setTextColor(Label id, Label name, Label time, Label date,
                              Label taskType, Color color) {
        id.setStyle("-fx-text-fill: #ff0000;");
        name.setStyle("-fx-text-fill: #ff0000;");
        time.setStyle("-fx-text-fill: #ff0000;");
        date.setStyle("-fx-text-fill: #ff0000;");
        taskType.setStyle("-fx-text-fill: #ff0000;-fx-font-size: 10pt;");
    }
```
###### /resources/css/StyleSheet.css
``` css
.root {
	-fx-body-color : #F5F5F5;
	-fx-outer-border : #cecece;
	-fx-font-family: "Century Gothic, sans-serif";
	
}
.text-field {
	-fx-font-size: 12pt;
    -fx-font-family: "Century Gothic, sans-serif";
}

.cell_big_label {
    -fx-font-family: "Century Gothic, sans-serif";
    -fx-font-size: 12px;
    -fx-text-fill: #010504;
}

.cell_small_label {
    -fx-font-family: "Century Gothic, sans-serif";
    -fx-font-size: 11px;
    -fx-text-fill: #010504;
}
.label {
    -fx-font-size: 12pt;
    -fx-font-family: "Century Gothic, sans-serif";
    -fx-text-fill: #333333;
    -fx-opacity: 0.9;
}

.anchor-pane {
     -fx-font-size: 10pt;
    -fx-font-family: "Century Gothic, sans-serif";
}

.grid-pane {
     -fx-background-color: #d6d6d6;
}
.status-bar {
    -fx-font-size: 10pt;
    -fx-font-family: "Century Gothic, sans-serif";
    -fx-text-fill: black;
}

#resultDisplay{
	-fx-font-size: 10pt;
    -fx-text-fill: #595959;
}
#resultDisplay .content {
    -fx-background-color: transparent, #c9c9c9, transparent, #c9c9c9;
    -fx-background-radius: 0;
    
}

.label-header {
    -fx-font-size: 32pt;
    -fx-font-family: "Century Gothic, sans-serif";
    -fx-text-fill: #333333;
    -fx-opacity: 1;
}

#tags {
    -fx-hgap: 7;
    -fx-vgap: 3;
}

#tags .label {

    -fx-font-size: 11;
}

#tags .label {
    -fx-text-fill: white;
    -fx-background-color: #3e7b91;
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 11;
}

.check-box:pressed > .box,
.radio-button:pressed > .radio {
	-fx-background-color: #50c0e2;
}
```
