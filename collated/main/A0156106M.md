# A0156106M
###### /java/seedu/whatsnext/logic/commands/AddCommand.java
``` java
/**
 * Adds a task to the task manager.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the task manager.\n"
            + "Parameters: "
            + "TASKNAME "
            + "[" + PREFIX_MESSAGE + "DESCRIPTIONS] "
            + "[" + PREFIX_START_DATETIME + "START_DATETIME] "
            + "[" + PREFIX_END_DATETIME + "END_DATETIME] "
            + "[" + PREFIX_TAG_CLI + "TAG] \n"
            + "Example: add Task1 m/this is an example s/today e/tomorrow 10pm t/tag ";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager";
    public static final String INVALID_TASK_CREATED = "Invalid Task Format";
    public static final String MESSAGE_OVERLAP_TASK = "This Task causes an overlapping Event Task.";

    private static final Logger logger = LogsCenter.getLogger(AddCommand.class);

    private BasicTask toAdd;

    /**
     * Creates an AddCommand to add the specified {@code BasicTaskFeatures}
     */
    public AddCommand(BasicTaskFeatures task) {
        toAdd = new BasicTask(task);
    }

```
###### /java/seedu/whatsnext/logic/commands/AddCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException, IllegalValueException {
        requireNonNull(model);
        ObservableList<BasicTask> taskList = model.getTaskManager().getTaskList();
        if (toAdd.isOverlapTask(taskList)) {
            toAdd = EditCommand.createOverlapTask(toAdd);
            logger.info(MESSAGE_OVERLAP_TASK + " Task name: " + toAdd.getName());
        }
        try {
            model.addTask(toAdd);
            int counter = 0;
            for (int i = 0; i < model.getFilteredTaskList().size(); i++) {
                if (toAdd.equals(model.getFilteredTaskList().get(i))) {
                    counter = i;
                    break;
                }
            }
            Index index = new Index(counter);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(index));
            logger.fine(String.format(MESSAGE_SUCCESS, toAdd));
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (DuplicateTaskException e) {
            model.resetPrevTaskManager();
            logger.info(MESSAGE_DUPLICATE_TASK + " Task name: " + toAdd.getName());
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
    }
}
```
###### /java/seedu/whatsnext/logic/commands/ClearCommand.java
``` java
    @Override
    public CommandResult execute() {
        requireNonNull(model);
        if (clearArgument.equals(CLEAR_ALL)) {
            model.resetData(new TaskManager());
            return new CommandResult(MESSAGE_SUCCESS);
        } else if (clearArgument.equals(CLEAR_COMPLETED)) {
            return clearCompletedOrIncomplete(COMPLETED_TASKS);
        } else if (clearArgument.equals(CLEAR_INCOMPLETE)) {
            return clearCompletedOrIncomplete(INCOMPLETE_TASKS);
        } else {
            return clearExpired();
        }
    }

```
###### /java/seedu/whatsnext/logic/commands/ClearCommand.java
``` java
    /**
     * Clears all completed/incomplete task based on the input parameter
     *
     * */
    private CommandResult clearCompletedOrIncomplete(boolean isCompletedOrIncomplete) {
        ReadOnlyTaskManager readOnlyTaskManager = model.getTaskManager();
        ObservableList<BasicTask> taskList = readOnlyTaskManager.getTaskList();
        TaskManager taskManager = new TaskManager();
        for (BasicTask basicTask: taskList) {
            if (isCompletedOrIncomplete ? basicTask.getIsCompleted() : !basicTask.getIsCompleted()) {
                try {
                    taskManager.addTask(basicTask);
                } catch (DuplicateTaskException e) {
                    e.printStackTrace();
                }
            }
        }

        taskManager.syncMasterTagListWith(taskManager.getTasks());
        model.resetData(taskManager);
        if (isCompletedOrIncomplete) {
            logger.info(MESSAGE_SUCCESS_CLEAR_INCOMPLETE);
            return new CommandResult(MESSAGE_SUCCESS_CLEAR_INCOMPLETE);
        } else {
            logger.info(MESSAGE_SUCCESS_CLEAR_COMPLETED);
            return new CommandResult(MESSAGE_SUCCESS_CLEAR_COMPLETED);
        }
    }

```
###### /java/seedu/whatsnext/logic/commands/EditCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException, TagNotFoundException, IllegalValueException {
        List<BasicTaskFeatures> lastShownList = model.getFilteredTaskList();

        if (index.getZeroBased() >= lastShownList.size()) {
            logger.info(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX + ": " + index.getOneBased());
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        BasicTaskFeatures taskToEdit = lastShownList.get(index.getZeroBased());
        BasicTask editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
        validateEditTask(editedTask);

        //UnmodifiableObservableList<BasicTaskFeatures> taskList = model.getFilteredTaskList();
        ObservableList<BasicTask> taskList = model.getTaskManager().getTaskList();

        try {
            if (editedTask.isOverlapTask(taskList, index.getZeroBased())) {
                editedTask = EditCommand.createOverlapTask(editedTask);
            } else {
                editedTask = EditCommand.createNonOverlapTask(editedTask);
            }

            model.updateTask(taskToEdit, editedTask);

        } catch (DuplicateTaskException dpe) {
            logger.info(MESSAGE_DUPLICATE_TASK + " Task name: " + editedTask.getName());
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException pnfe) {
            logger.warning("Targeted task missing!");
            throw new AssertionError("The target task cannot be missing");
        }
        int counter = 0;
        for (int i = 0; i < model.getFilteredTaskList().size(); i++) {
            if (taskToEdit.equals(model.getFilteredTaskList().get(i))) {
                counter = i;
                break;
            }
        }
        Index index = new Index(counter);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(index));
        logger.fine(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

    /**
    * Checks the new editedTask created to ensure that the edited task value(s) is/are valid
    * @throws CommandException if edited task is invalid
    */
    public void validateEditTask(BasicTask editedTask) throws CommandException {
        if ((editedTask.getTaskType().equals(BasicTask.TASK_TYPE_EVENT)
                && editedTask.getEndDateTime().toString().equals(DateTime.INIT_DATETIME_VALUE))
                || (editedTask.getTaskType().equals(BasicTask.TASK_TYPE_EVENT)
                        && editedTask.getEndDateTime().isBefore(editedTask.getStartDateTime()))) {
            logger.info(Messages.MESSAGE_INVALID_FLOATING_TO_EVENT_TASK);
            throw new CommandException(Messages.MESSAGE_INVALID_FLOATING_TO_EVENT_TASK);
        }
    }

```
###### /java/seedu/whatsnext/logic/commands/EditCommand.java
``` java
    /**
     * Creates a new overlap BasicTask based on @param taskToMark
     * @return marked BasicTask
     * */
    static BasicTask createOverlapTask(BasicTaskFeatures taskToMark) {
        assert taskToMark != null;
        BasicTask toCopy = new BasicTask(taskToMark);
        TaskName updatedName = toCopy.getName();
        TaskDescription updatedDescription = toCopy.getDescription();
        DateTime startDateTime = toCopy.getStartDateTime();
        DateTime endDateTime = toCopy.getEndDateTime();
        boolean updateIsComplete = toCopy.getIsCompleted();
        Set<Tag> copyTags = toCopy.getTags();
        Set<Tag> updatedTags = new HashSet<Tag>(copyTags);

        try {
            updatedTags.add(new Tag(Tag.RESERVED_TAG_OVERLAP));
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
        return new BasicTask(updatedName, updatedDescription,
                updateIsComplete, startDateTime, endDateTime, updatedTags);
    }

    static BasicTask createNonOverlapTask(BasicTaskFeatures taskToMark) {
        assert taskToMark != null;
        BasicTask toCopy = new BasicTask(taskToMark);
        TaskName updatedName = toCopy.getName();
        TaskDescription updatedDescription = toCopy.getDescription();
        DateTime startDateTime = toCopy.getStartDateTime();
        DateTime endDateTime = toCopy.getEndDateTime();
        boolean updateIsComplete = toCopy.getIsCompleted();
        Set<Tag> copyTags = toCopy.getTags();
        Set<Tag> updatedTags = new HashSet<Tag>();
        for (Tag tag : copyTags) {
            if (!tag.tagName.equals(Tag.RESERVED_TAG_OVERLAP)) {
                try {
                    updatedTags.add(new Tag(tag.tagName));
                } catch (IllegalValueException e) {
                    e.printStackTrace();
                }
            }
        }

        return new BasicTask(updatedName, updatedDescription,
                updateIsComplete, startDateTime, endDateTime, updatedTags);
    }



```
###### /java/seedu/whatsnext/logic/commands/EditCommand.java
``` java
        public void setDescription(TaskDescription description) {
            this.description = description;
        }

        public Optional<TaskDescription> getDescription() {
            return Optional.ofNullable(description);
        }

```
###### /java/seedu/whatsnext/logic/commands/HelpCommand.java
``` java
/**
 * Format full help instructions for every command for display.
 */
public class HelpCommand extends Command {

    public static final String COMMAND_WORD = "help";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Shows program usage instructions.\n"
            + "Example: \n"
            + COMMAND_WORD + "\n"
            + COMMAND_WORD + " " + AddCommand.COMMAND_WORD;

    public static final String SHOWING_HELP_MESSAGE = "Opened help window.";

    public static final boolean OPEN_WINDOW = true;
    public static final boolean CLOSE_WINDOW = false;

    private boolean displayWindow = OPEN_WINDOW;
    private String helpMessage;

    public HelpCommand() {
        displayWindow = OPEN_WINDOW;
        helpMessage = SHOWING_HELP_MESSAGE;
    }

    public HelpCommand(String command) {
        displayWindow = CLOSE_WINDOW;
        helpMessage = showMessageUsage(command);

    }

    @Override
    public CommandResult execute() {
        if (displayWindow == OPEN_WINDOW) {
            EventsCenter.getInstance().post(new ShowHelpRequestEvent());
        }
        return new CommandResult(helpMessage);
    }

    /**
     * Returns respective MESSAGE_USAGE based on input commands
     * */
    public String showMessageUsage(String args) {
        String messageUsage;
        switch (args) {
        case AddCommand.COMMAND_WORD:
            messageUsage = AddCommand.MESSAGE_USAGE;
            break;
        case EditCommand.COMMAND_WORD:
            messageUsage = EditCommand.MESSAGE_USAGE;
            break;
        case SelectCommand.COMMAND_WORD:
            messageUsage = SelectCommand.MESSAGE_USAGE;
            break;
        case DeleteCommand.COMMAND_WORD:
            messageUsage = DeleteCommand.MESSAGE_USAGE;
            break;
        case ChangePathCommand.COMMAND_WORD:
            messageUsage = ChangePathCommand.MESSAGE_USAGE;
            break;
        case FilePathCommand.COMMAND_WORD:
            messageUsage = FilePathCommand.MESSAGE_USAGE;
            break;
        case MarkCommand.COMMAND_WORD:
            messageUsage = MarkCommand.MESSAGE_USAGE;
            break;
        case UnmarkCommand.COMMAND_WORD:
            messageUsage = UnmarkCommand.MESSAGE_USAGE;
            break;
        case ClearCommand.COMMAND_WORD:
            messageUsage = ClearCommand.MESSAGE_USAGE;
            break;
        case FindCommand.COMMAND_WORD:
            messageUsage = FindCommand.MESSAGE_USAGE;
            break;
        case ListCommand.COMMAND_WORD:
            messageUsage = ListCommand.MESSAGE_USAGE;
            break;
        case UndoCommand.COMMAND_WORD:
            messageUsage = UndoCommand.MESSAGE_USAGE;
            break;
        case RedoCommand.COMMAND_WORD:
            messageUsage = RedoCommand.MESSAGE_USAGE;
            break;
        case RemindCommand.COMMAND_WORD:
            messageUsage = RemindCommand.MESSAGE_USAGE;
            break;
        case HistoryCommand.COMMAND_WORD:
            messageUsage = HistoryCommand.MESSAGE_USAGE;
            break;
        case ResetCommand.COMMAND_WORD:
            messageUsage = ResetCommand.MESSAGE_USAGE;
            break;
        default:
            messageUsage = HelpCommand.MESSAGE_USAGE;
        }

        return messageUsage;
    }

    @Override
    public boolean equals(Object other) {
        if (other == this) {
            return true;
        }

        // instanceof handles nulls
        if (!(other instanceof HelpCommand)) {
            return false;
        }

        HelpCommand e = (HelpCommand) other;
        return e.displayWindow == this.displayWindow
                && e.helpMessage.equals(this.helpMessage);
    }
}
```
###### /java/seedu/whatsnext/logic/commands/HistoryCommand.java
``` java
/**
 * Lists all the commands entered by user from the start of app launch.
 */
public class HistoryCommand extends Command {

    public static final String COMMAND_WORD = "history";
    public static final String MESSAGE_SUCCESS = "Entered commands (from earliest to most recent):\n%1$s";
    public static final String MESSAGE_NO_HISTORY = "You have not yet entered any commands.";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": displays previous commands typed.\n"
            + "Example: history ";

    @Override
    public CommandResult execute() {
        List<String> previousCommands = history.getHistory();

        if (previousCommands.isEmpty()) {
            return new CommandResult(MESSAGE_NO_HISTORY);
        }

        return new CommandResult(String.format(MESSAGE_SUCCESS, String.join("\n", previousCommands)));
    }

    @Override
    public void setData(Model model, CommandHistory history) {
        requireNonNull(history);
        this.history = history;
    }
}
```
###### /java/seedu/whatsnext/logic/commands/MarkCommand.java
``` java
/**
 * Marks an existing task as completed in the task manager.
 */
public class MarkCommand extends Command {

    public static final String COMMAND_WORD = "mark";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": marks the task identified by the index number used in the last task listing to 'completed'.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Marked Task: %1$s";
    public static final String MESSAGE_TASK_MARKED = "Selected task is already marked";

    public static final String MESSAGE_TASK_MISSING_ERROR = "The target task cannot be missing";


    private static final Logger logger = LogsCenter.getLogger(MarkCommand.class);
    public final Index targetIndex;

    public MarkCommand(Index targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() throws CommandException, DuplicateTaskException {
        List<BasicTaskFeatures> lastShownList = model.getFilteredTaskList();
        if (targetIndex.getZeroBased() >= lastShownList.size()) {
            logger.info(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX + ": " + targetIndex.getOneBased());
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        BasicTaskFeatures taskToMark = lastShownList.get(targetIndex.getZeroBased());
        if (taskToMark.getIsCompleted()) {
            logger.info(MESSAGE_TASK_MARKED + ": " + targetIndex.getOneBased());
            throw new CommandException(MESSAGE_TASK_MARKED);
        }

        BasicTask markedTask = createMarkedTask(taskToMark);
        try {
            model.updateTask(taskToMark, markedTask);
        } catch (TaskNotFoundException e) {

            logger.warning("Targeted task missing!");
            throw new AssertionError("The target task cannot be missing");

        }
        logger.fine(String.format(MESSAGE_MARK_TASK_SUCCESS, taskToMark));
        return new CommandResult(String.format(MESSAGE_MARK_TASK_SUCCESS, taskToMark));
    }

```
###### /java/seedu/whatsnext/logic/commands/MarkCommand.java
``` java
    /**
     * Creates a new marked BasicTask based on @param taskToMark
     * @return marked BasicTask
     * */
    private static BasicTask createMarkedTask(BasicTaskFeatures taskToMark) {
        assert taskToMark != null;
        BasicTask toCopy = new BasicTask(taskToMark);
        TaskName updatedName = toCopy.getName();
        TaskDescription updatedDescription = toCopy.getDescription();
        DateTime startDateTime = toCopy.getStartDateTime();
        DateTime endDateTime = toCopy.getEndDateTime();
        toCopy.setCompleted();
        boolean updateIsComplete = toCopy.getIsCompleted();
        Set<Tag> updatedTags = toCopy.getTags();
        return new BasicTask(updatedName, updatedDescription,
                updateIsComplete, startDateTime, endDateTime, updatedTags);
    }

}
```
###### /java/seedu/whatsnext/logic/commands/UnmarkCommand.java
``` java
/**
 * Marks an existing completed task as incomplete in the task manager.
 */
public class UnmarkCommand extends Command {
    public static final String COMMAND_WORD = "unmark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": unmarks the task identified by the index number used in the last task listing to 'completed'.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_UNMARK_TASK_SUCCESS = "Unmarked Task: %1$s";

    public static final String MESSAGE_TASK_UNMARKED = "Selected task is already unmarked";

    private static final Logger logger = LogsCenter.getLogger(UnmarkCommand.class);

    public final Index targetIndex;

    public UnmarkCommand(Index targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() throws CommandException, DuplicateTaskException {
        List<BasicTaskFeatures> lastShownList = model.getFilteredTaskList();

        if (targetIndex.getZeroBased() >= lastShownList.size()) {
            logger.info(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX + ": " + targetIndex.getOneBased());
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        BasicTaskFeatures taskToMark = lastShownList.get(targetIndex.getZeroBased());
        BasicTask markedTask = createUnmarkedTask(taskToMark);
        if (!taskToMark.getIsCompleted()) {
            logger.info(MESSAGE_TASK_UNMARKED + ": " + targetIndex.getOneBased());
            throw new CommandException(MESSAGE_TASK_UNMARKED);
        }
        try {
            model.updateTask(taskToMark, markedTask);
        } catch (TaskNotFoundException e) {
            logger.warning("Targeted task missing!");
            throw new AssertionError("The target task cannot be missing");
        }
        logger.fine(String.format(MESSAGE_UNMARK_TASK_SUCCESS, taskToMark));
        return new CommandResult(String.format(MESSAGE_UNMARK_TASK_SUCCESS, taskToMark));
    }

```
###### /java/seedu/whatsnext/logic/commands/UnmarkCommand.java
``` java
    /**
     * Creates a new unmarked BasicTask based on @param taskToUnmark
     * @return marked BasicTask
     * */
    private static BasicTask createUnmarkedTask(BasicTaskFeatures taskToUnmark) {
        assert taskToUnmark != null;
        BasicTask toCopy = new BasicTask(taskToUnmark);
        TaskName updatedName = toCopy.getName();
        TaskDescription updateDescription = toCopy.getDescription();
        DateTime startDateTime = toCopy.getStartDateTime();
        DateTime endDateTime = toCopy.getEndDateTime();
        toCopy.setIncomplete();
        boolean updateIsComplete = toCopy.getIsCompleted();
        Set<Tag> updatedTags = toCopy.getTags();
        return new BasicTask(updatedName, updateDescription, updateIsComplete, startDateTime, endDateTime, updatedTags);
    }

}
```
###### /java/seedu/whatsnext/logic/parser/AddCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     * @throws ParseException if the user input does not conform the expected format
     */
    public AddCommand parse(String args) throws ParseException {
        try {
            if (args.contains(PREFIX_START_DATETIME.toString()) || args.contains(PREFIX_END_DATETIME.toString())
                    || args.contains(PREFIX_MESSAGE.toString()) || args.contains(PREFIX_TAG_CLI.toString())) {
                return parseCommandByPrefix(args);
            } else {
                return parseCommandByComma(args);
            }
        } catch (IllegalValueException ive) {
            throw new ParseException(ive.getMessage() + "\n" + AddCommand.MESSAGE_USAGE, ive);
        }
    }

    /**
     * Parses the argument based on Prefix
     * @return AddCommand Object based on tokenized Prefix
     * */
    private AddCommand parseCommandByPrefix(String args) throws IllegalValueException {
        ArgumentMultimap argMultimap =
                ArgumentTokenizer.tokenize(args, PREFIX_MESSAGE, PREFIX_START_DATETIME,
                        PREFIX_END_DATETIME, PREFIX_TAG_CLI);
        TaskName taskName = new TaskName(argMultimap.getPreamble());
        Optional<String> startDateTimeValue = argMultimap.getValue(PREFIX_START_DATETIME);
        Optional<String> endDateTimeValue = argMultimap.getValue(PREFIX_END_DATETIME);
        Optional<String> taskDescriptionValue = argMultimap.getValue(PREFIX_MESSAGE);
        Set<Tag> tagList = ParserUtil.parseTags(argMultimap.getAllValues(PREFIX_TAG_CLI));

        BasicTask task = createBasicTaskBasedOnInputs(taskName, taskDescriptionValue,
                startDateTimeValue, endDateTimeValue, tagList);
        return new AddCommand(task);
    }

    /**
     * Parses the argument based on Comma
     * @return AddCommand Object based on tokenized values
     * */
    private AddCommand parseCommandByComma(String args) throws IllegalValueException {
        SplitCommaParser splitCommandParser = new SplitCommaParser();
        splitCommandParser.tokenize(args);

        TaskName taskName = new TaskName(splitCommandParser.getTaskName());
        Optional<String> startDateTimeValue = splitCommandParser.getStartDateTime();
        Optional<String> endDateTimeValue = splitCommandParser.getEndDateTime();
        Optional<String> taskDescriptionValue = splitCommandParser.getDescription();
        if (startDateTimeValue.isPresent() && !endDateTimeValue.isPresent()) {
            endDateTimeValue = startDateTimeValue;
            startDateTimeValue = Optional.empty();
        }
        Set<Tag> tagList = splitCommandParser.parseTags();

        BasicTask task = createBasicTaskBasedOnInputs(taskName, taskDescriptionValue,
                startDateTimeValue, endDateTimeValue, tagList);
        return new AddCommand(task);
    }

    /**
     * Creates the Basic Task object base on the value of startDateTimeValue and endDateTimeValue
     * @return BasicTask object
     * @throws ParseException if the user input does not conform the expected format
     */
    private BasicTask createBasicTaskBasedOnInputs(
            TaskName taskName, Optional<String> taskDescriptionValue, Optional<String> startDateTimeValue,
            Optional<String> endDateTimeValue, Set<Tag> tagList) throws IllegalValueException {
        BasicTask task;
        TaskDescription taskDescription = new TaskDescription();
        if (taskDescriptionValue.isPresent()) {
            taskDescription = new TaskDescription(taskDescriptionValue.get());
        }
        // Create Event Task
        if (startDateTimeValue.isPresent() && endDateTimeValue.isPresent()) {
            DateTime startDateTime = new DateTime(startDateTimeValue.get());
            DateTime endDateTime = new DateTime(endDateTimeValue.get());
            validateStartEndDateTime(startDateTime, endDateTime);
            task = new BasicTask(taskName, taskDescription, false, startDateTime, endDateTime, tagList);

        // Create Deadline Task
        } else if (endDateTimeValue.isPresent()) {
            DateTime endDateTime = new DateTime(endDateTimeValue.get());
            task = new BasicTask(taskName, taskDescription, false, endDateTime, tagList);

        // Invalid Task
        } else if (startDateTimeValue.isPresent() && !endDateTimeValue.isPresent()) {
            throw new IllegalValueException(AddCommand.INVALID_TASK_CREATED);

        // Create Floating Task
        } else {
            task = new BasicTask(taskName, taskDescription, false, tagList);
        }
        return task;
    }

    /**
     * Ensures that the startDateTime is not after the endDateTime
     * @throws IllegalValueException
     * */
    private void validateStartEndDateTime(DateTime startDateTime, DateTime endDateTime) throws IllegalValueException {
        if (!startDateTime.isBefore(endDateTime)) {
            throw new IllegalValueException(AddCommand.INVALID_TASK_CREATED);
        }
    }


}
```
###### /java/seedu/whatsnext/logic/parser/ClearCommandParser.java
``` java
/**
 * Parse input arguments and creates a new ClearCommand Object
 * */
public class ClearCommandParser {

    /**
     * Parse the given {@code String} of arguments in the context of the ClearCommand
     * and returns a ClearCommand object for execution
     * @throws ParseException if the user input does not conform the expected format
     * */
    public ClearCommand parse(String args) throws ParseException {
        ArgumentMultimap argMultimap = ArgumentTokenizer.tokenize(args);
        String clearArgument = argMultimap.getPreamble().trim();
        if (!isArgumentValidPrefixesPresent(clearArgument)) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ClearCommand.MESSAGE_USAGE));
        }
        return new ClearCommand(clearArgument);
    }

    /**
     * Checks if clear command argument is valid
     * @return true if argument matches 'completed', 'incomplete', 'all' and 'expired'
     * */
    private boolean isArgumentValidPrefixesPresent(String clearArgument) {
        return clearArgument.matches(".*\\b(completed|incomplete|all|expired)\\b.*");
    }
}
```
###### /java/seedu/whatsnext/logic/parser/CliSyntax.java
``` java
    public static final Prefix PREFIX_DESCRIPTION = new Prefix("m/");
    public static final Prefix PREFIX_TO = new Prefix("to");
    public static final Prefix PREFIX_ON = new Prefix("on");
    public static final Prefix PREFIX_ALL = new Prefix("all");
    public static final Prefix PREFIX_COMPLETED = new Prefix("completed");
    public static final Prefix PREFIX_INCOMPLETE = new Prefix("incomplete");

```
###### /java/seedu/whatsnext/logic/parser/HelpCommandParser.java
``` java
/**
 * Parses input arguments and creates a new HelpCommand object
 * */
public class HelpCommandParser {

    public HelpCommand parse(String args) throws ParseException {
        if (args.isEmpty()) {
            return new HelpCommand();
        }
        String helpCommandArgument = args.trim();
        if (isValid(helpCommandArgument)) {
            return new HelpCommand(helpCommandArgument);
        } else {
            throw new ParseException(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

    }

    /**
     * Checks if help command is valid
     * @return true if it is valid
     * */
    public boolean isValid(String args) {
        if (args.equals(AddCommand.COMMAND_WORD)
                || args.equals(EditCommand.COMMAND_WORD) || args.equals(SelectCommand.COMMAND_WORD)
                || args.equals(DeleteCommand.COMMAND_WORD) || args.equals(ChangePathCommand.COMMAND_WORD)
                || args.equals(FilePathCommand.COMMAND_WORD) || args.equals(MarkCommand.COMMAND_WORD)
                || args.equals(UnmarkCommand.COMMAND_WORD) || args.equals(ClearCommand.COMMAND_WORD)
                || args.equals(FindCommand.COMMAND_WORD) || args.equals(ListCommand.COMMAND_WORD)
                || args.equals(UndoCommand.COMMAND_WORD) || args.equals(RedoCommand.COMMAND_WORD)
                || args.equals(RemindCommand.COMMAND_WORD) || args.equals(HistoryCommand.COMMAND_WORD)
                || args.equals(HelpCommand.COMMAND_WORD) || args.equals(ResetCommand.COMMAND_WORD)) {
            return true;
        }
        return false;
    }

}
```
###### /java/seedu/whatsnext/logic/parser/MarkCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the MarkCommand
     * and returns a MarkCommand object for execution
     * @throws ParseException if the user input does not confirm the expected format
     * */
    public MarkCommand parseMarkCommand(String args) throws ParseException {
        try {
            Index index = ParserUtil.parseIndex(args);
            return new MarkCommand(index);
        } catch (IllegalValueException ive) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }
    }

    /**
     * Parses the given {@code String} of arguments in the context of the UnmarkCommand
     * and returns an UnmarkCommand object for execution
     * @throws ParseException if the user input does not confirm the expected format
     * */
    public UnmarkCommand parseUnmarkCommand(String args) throws ParseException {
        try {
            Index index = ParserUtil.parseIndex(args);
            return new UnmarkCommand(index);
        } catch (IllegalValueException ive) {
            throw new ParseException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }
    }

}
```
###### /java/seedu/whatsnext/logic/parser/Parser.java
``` java
        case AddCommand.COMMAND_WORD:
            return new AddCommandParser().parse(arguments);

```
###### /java/seedu/whatsnext/logic/parser/Parser.java
``` java
        case MarkCommand.COMMAND_WORD:
            return new MarkCommandParser().parseMarkCommand(arguments);

```
###### /java/seedu/whatsnext/logic/parser/Parser.java
``` java
        case UnmarkCommand.COMMAND_WORD:
            return new MarkCommandParser().parseUnmarkCommand(arguments);

```
###### /java/seedu/whatsnext/logic/parser/Parser.java
``` java
        case ClearCommand.COMMAND_WORD:
            return new ClearCommandParser().parse(arguments);

```
###### /java/seedu/whatsnext/logic/parser/Parser.java
``` java
        case HelpCommand.COMMAND_WORD:
            return new HelpCommandParser().parse(arguments);

        default:
            throw new ParseException(MESSAGE_UNKNOWN_COMMAND);
        }
    }

}
```
###### /java/seedu/whatsnext/logic/parser/ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     */
    public static Optional<String> parseType(Optional<String> name) throws IllegalValueException {
        requireNonNull(name);
        return name.isPresent() ? Optional.of(new String(name.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> name} into an {@code Optional<Name>} if {@code name} is present.
     */
    public static Optional<TaskDescription> parseDescription(Optional<String> description)
            throws IllegalValueException {
        requireNonNull(description);
        return description.isPresent() ? Optional.of(new TaskDescription(description.get())) : Optional.empty();
    }

```
###### /java/seedu/whatsnext/logic/parser/ParserUtil.java
``` java
    /**
     * Parses {@code Optional<String> tags} into a {@code Set<Tag>}.
     * @return {@code Set<tag>} which represent all tags
     */
    public static Set<Tag> parseMultipleTags(Optional<String> tagStringInput) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        if (tagStringInput.isPresent()) {
            String tagString = tagStringInput.get();
            String[] tagList = tagString.split(" ");
            for (String tagName : tagList) {
                tagSet.add(new Tag(tagName.trim()));
            }
        }
        return tagSet;
    }

```
###### /java/seedu/whatsnext/logic/parser/SplitCommaParser.java
``` java
/**
 * Tokenizes arguments string of the form:
 * {@code taskName, taskDescription, taskStartDate, taskEndDate, tags: taskTags}
 * 1. An argument's value can be an empty string e.g. the value of {@code k/} in the above example.<br>
 * 2. Leading and trailing whitespaces of an argument value will be discarded.<br>
 * 3. An argument may be repeated and all its values will be accumulated e.g. the value of {@code t/}
 *    in the above example.<br>
 *
 * */

public class SplitCommaParser {
    private static final String TASK_NAME = "name";
    private static final String TASK_DESCRIPTION = "description";
    private static final String TASK_DATETIME = "end";
    private static final String TASK_TAG = "tag";

    private HashMap<String, List<String>> parserMap = new HashMap<>();
    private ArrayList<String> nameList = new ArrayList<>();
    private ArrayList<String> descriptionList = new ArrayList<>();
    private ArrayList<String> dateTimeList = new ArrayList<>();
    private ArrayList<String> tagList = new ArrayList<>();

    /**
     * Splits the argument by comma "," and maps each tokenized argument by their attributes
     * @param: inputValue Arguments string of the form
     * {@code taskName, taskDescription, taskStartDate, taskEndDate, tags: taskTags}
     * @return {@code HashMap<String, List<String>> object}
     * */
    public HashMap<String, List<String>> tokenize(String inputValue) {

        String[] splitInputValue = inputValue.split(",");
        nameList.add(splitInputValue[0]);
        parserMap.put(TASK_NAME, nameList);

        for (int i = 1; i < splitInputValue.length; i++) {
            String value = splitInputValue[i];
            if (isValidDescription(value)) {
                descriptionList.add(value);
            } else if (isValidDateTime(value)) {
                dateTimeList.add(value);
            } else if (isValidTag(value)) {
                tagList = getTags(value);
            }
        }
        parserMap.put(TASK_DESCRIPTION, descriptionList);
        parserMap.put(TASK_DATETIME, dateTimeList);
        parserMap.put(TASK_TAG, tagList);

        return parserMap;
    }

    /**
     * Returns first taskName recorded
     * */
    public String getTaskName() {
        return parserMap.get(TASK_NAME).get(0);
    }

    /**
     * Returns first taskDescription recorded
     * */
    public Optional<String> getDescription() {
        if (parserMap.get(TASK_DESCRIPTION).isEmpty()) {
            return Optional.empty();
        }
        String descriptionValue = parserMap.get(TASK_DESCRIPTION).get(0);
        descriptionValue = descriptionValue.trim();
        descriptionValue = descriptionValue.substring(1);
        descriptionValue = descriptionValue.substring(0, descriptionValue.length() - 1);
        return Optional.of(descriptionValue);
    }

    /**
     * Returns first task DateTime recorded
     * */
    public Optional<String> getStartDateTime() {
        if (parserMap.get(TASK_DATETIME).isEmpty()) {
            return Optional.empty();
        }

        return Optional.of(parserMap.get(TASK_DATETIME).get(0));
    }

    /**
     * Returns second task DateTime recorded
     * */
    public Optional<String> getEndDateTime() {
        if (parserMap.get(TASK_DATETIME).size() > 1) {
            return Optional.of(parserMap.get(TASK_DATETIME).get(1));
        }
        return Optional.empty();
    }

    /**
     * Checks if argument is a valid taskDescription argument
     * descriptions are enclosed in ""
     * @return true if arguments starts and ends with open inverted commas
     * */
    private boolean isValidDescription(String args) {
        String inputValue = args.trim();
        return inputValue.startsWith("\"") && inputValue.endsWith("\"");
    }

    /**
     * Checks if argument is valid Date Time argument
     * */
    private boolean isValidDateTime(String args) {
        List<Date> dateInputList = new PrettyTimeParser().parse(args);
        if (dateInputList.isEmpty()) {
            return false;
        }
        return true;
    }


    Set<Tag> parseTags() throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tagList) {
            tagName = tagName.trim();
            tagSet.add(new Tag(tagName));
        }
        return tagSet;
    }

    /**
     * Checks if argument is a valid taskDescription argument
     * @return true if argument starts with "tags:"
     * */
    private boolean isValidTag(String args) {
        String inputValue = args.trim();
        if (inputValue.length() < 5) {
            return false;
        }
        String tagKey = inputValue.substring(0, 5);
        if (tagKey.equals("tags:")) {
            return true;
        }
        return false;
    }

    /**
     * @param Valid tag argument
     * @return ArrayList of possible tag names
     * */
    private ArrayList<String> getTags(String args) {
        String inputValue = args.substring(6);
        ArrayList<String> splitTagList = new ArrayList<>();
        for (String value : inputValue.split(" ")) {
            if (!value.isEmpty()) {
                splitTagList.add(value.trim());
            }
        }
        return splitTagList;
    }

}
```
###### /java/seedu/whatsnext/model/tag/UniqueTagList.java
``` java
    /**
     * Returns true if the list contains priority "OVERLAP" tag
     * */
    public boolean containsOverlapTag() throws IllegalValueException {
        final Tag overlapTag = new Tag(Tag.RESERVED_TAG_OVERLAP);
        return internalList.contains(overlapTag);
    }

```
###### /java/seedu/whatsnext/model/task/BasicTask.java
``` java
/**
 * Represents a Basic Task in the WhatsNext application.
 * Basic Tasks are only able to store task name, task description and tags
 * Guarantees: details are present and not null, field values are validated.
 */
public class BasicTask implements BasicTaskFeatures {
    public static final String TASK_COMPLETED = "Completed";
    public static final String TASK_INCOMPLETE = "Incomplete";
    public static final String TASK_TYPE_FLOATING = "floating";
    public static final String TASK_TYPE_DEADLINE = "deadline";
    public static final String TASK_TYPE_EVENT = "event";
    private DateTime startDateTime;
    private DateTime endDateTime;
    private String taskType;
    private TaskName taskName;
    private TaskDescription taskDescription;
    private boolean isCompleted;
    private UniqueTagList tags;

    /**
     * Constructor for Floating
     * @throws IllegalValueException
     * */
    public BasicTask(TaskName taskName, TaskDescription taskDescription,
            boolean isCompleted, Set<Tag> tags) throws IllegalValueException {
        this (taskName, taskDescription, isCompleted, new DateTime(), new DateTime(), tags);
    }

    public BasicTask(TaskName taskName, TaskDescription taskDescription, Set<Tag> tags) throws IllegalValueException {
        this (taskName, taskDescription, false, new DateTime(), new DateTime(), tags);
    }

    public BasicTask(TaskName taskName, Set<Tag> tags) throws IllegalValueException {
        this (taskName, new TaskDescription(), false, new DateTime(), new DateTime(), tags);
    }

    /**
     * Constructor for Deadline
     * @throws IllegalValueException
     * */
    public BasicTask(TaskName taskName, TaskDescription taskDescription, DateTime endDateTime, Set<Tag> tags)
            throws IllegalValueException {
        this (taskName, taskDescription, false, new DateTime(), endDateTime, tags);
    }

    public BasicTask(TaskName taskName, TaskDescription taskDescription,
            boolean isCompleted, DateTime endDateTime, Set<Tag> tags)
            throws IllegalValueException {
        this (taskName, taskDescription, isCompleted, new DateTime(), endDateTime, tags);
    }

    public BasicTask(TaskName taskName, TaskDescription taskDescription,
            DateTime startDateTime, DateTime endDateTime, Set<Tag> tags)
            throws IllegalValueException {
        this (taskName, taskDescription, false, startDateTime, endDateTime, tags);
    }

    /**
     * Constructor for Event
     * @throws IllegalValueException
     * */
    public BasicTask(TaskName taskName, TaskDescription taskDescription, boolean isCompleted,
            DateTime startDateTime, DateTime endDateTime, Set<Tag> tags) {
        //assert (startDateTime.isEmpty() && !endDateTime.isEmpty());
        this.taskName = taskName;
        this.taskDescription = taskDescription;
        this.tags = new UniqueTagList(tags);
        this.isCompleted = isCompleted;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        setTaskType();
    }

    public BasicTask(BasicTaskFeatures source) {
        this (source.getName(), source.getDescription(), source.getIsCompleted(),
                source.getStartDateTime(), source.getEndDateTime(), source.getTags());
    }

```
###### /java/seedu/whatsnext/model/task/BasicTask.java
``` java
    /**
     * Sets the taskType of a BasicTask based on the value of startDateTime and endDateTime
     * */
    public void setTaskType() {
        if (this.startDateTime.isEmpty() && this.endDateTime.isEmpty()) {
            taskType = TASK_TYPE_FLOATING;
        } else if (this.startDateTime.isEmpty() && !this.endDateTime.isEmpty()) {
            taskType = TASK_TYPE_DEADLINE;
        } else {
            taskType = TASK_TYPE_EVENT;
        }
    }

    @Override
    public boolean eventTaskOverlap(BasicTaskFeatures task) {
        return (this.getTaskType().equals(TASK_TYPE_EVENT) && task.getTaskType().equals(TASK_TYPE_EVENT)
                && this.getStartDateTime().isBeforeOrEqual(task.getEndDateTime())
                && task.getStartDateTime().isBeforeOrEqual(this.getEndDateTime()));
    }

    public void setName(TaskName name) {
        this.taskName = requireNonNull(name);
    }

    public void setDescription(TaskDescription description) {
        this.taskDescription = requireNonNull(description);
    }

    @Override
    public TaskName getName() {
        return taskName;
    }

    /**
     * Returns an immutable tag set, which throws {@code UnsupportedOperationException}
     * if modification is attempted.
     */
    @Override
    public Set<Tag> getTags() {
        return Collections.unmodifiableSet(tags.toSet());
    }

    /**
     * Replaces this task's tags with the tags in the argument tag set.
     */
    public void setTags(Set<Tag> replacement) {
        tags.setTags(new UniqueTagList(replacement));
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(BasicTaskFeatures replacement) {
        requireNonNull(replacement);
        this.setName(replacement.getName());
        this.setTags(replacement.getTags());
        this.setDescription(replacement.getDescription());
        this.isCompleted = (replacement.getIsCompleted());
        this.startDateTime = (replacement.getStartDateTime());
        this.endDateTime = (replacement.getEndDateTime());
        setTaskType();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof BasicTaskFeatures // instanceof() handles nulls
                && this.isSameStateAs((BasicTaskFeatures) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(taskName, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    @Override
    public boolean getIsCompleted() {
        return isCompleted;
    }


    @Override
    public void setCompleted() {
        isCompleted = true;
    }

    @Override
    public void setIncomplete() {
        isCompleted = false;
    }

    @Override
    public DateTime getStartDateTime() {
        return startDateTime;
    }

    @Override
    public DateTime getEndDateTime() {
        return endDateTime;
    }

    @Override
    public String getTaskType() {
        return taskType;
    }

    @Override
    public String getStatusString() {
        if (getIsCompleted()) {
            return TASK_COMPLETED;
        } else {
            return TASK_INCOMPLETE;
        }
    }

    @Override
    public void setStartDateTime(DateTime dateTime) {
        startDateTime = dateTime;
        setTaskType();
    }

    @Override
    public void setEndDateTime(DateTime dateTime) {
        endDateTime = dateTime;
        setTaskType();
    }

    @Override
    public TaskDescription getDescription() {
        return taskDescription;
    }

    /**
     * Checks if basicTask is overlap any other BasicTasks with taskType "event"
     * @return true if event task overlaps another task
     * */
    public boolean isOverlapTask(ObservableList<BasicTask> taskList) throws IllegalValueException  {
        for (BasicTaskFeatures task : taskList) {
            if (this.eventTaskOverlap(task) && (!this.equals(task))) {
                return true;
            }
        }
        return false;
    }

    /**
     * @return true if task is on overlapped task
     * */
    public boolean isOverlapTask(ObservableList<BasicTask> taskList, int index)
                                throws IllegalValueException {
        int i = 0;
        for (BasicTaskFeatures task : taskList) {
            if ((i != index) && this.eventTaskOverlap(task) && (!this.equals(task))) {
                return true;
            }
            i++;
        }
        return false;
    }

    /**
     * Displays the task details
     * */
    @Override
    public String getTaskDetails() {
        StringBuilder details = new StringBuilder();
        if (this.getTaskType().equals("event")) {
            details.append("Task name: " + this.getName() + "\n"
                + "Tags: " + this.getAllTags() + "\n"
                + "Status: " + this.getStatusString() + "\n"
                + "From: " + this.getStartDateTime().displayDateTime() + " "
                + "To: " + this.getEndDateTime().displayDateTime() + "\n"
                + "Description: " + this.getDescription().toString());
        } else if (this.getTaskType().equals("deadline")) {
            details.append("Task name: " + this.getName() + "\n"
                    + "Tags: " + this.getAllTags() + "\n"
                    + "Status: " + this.getStatusString() + "\n"
                    + "Due by: " + this.getEndDateTime().displayDateTime() + "\n"
                    + "Description: " + this.getDescription().toString());
        } else if (this.getTaskType().equals("floating")) {
            details.append("Task name: " + this.getName() + "\n"
                    + "Tags: " + this.getAllTags() + "\n"
                    + "Status: " + this.getStatusString() + "\n"
                    + "Description: " + this.getDescription().toString());
        }
        return details.toString();
    }

}
```
###### /java/seedu/whatsnext/model/task/BasicTaskFeatures.java
``` java
/**
 * A read-only immutable interface for a task in the WhatsNext application.
 * Implementations should guarantee: details are present and not null, field values are validated.
 *
 */
public interface BasicTaskFeatures {

    TaskName getName();
    TaskDescription getDescription();
    Set<Tag> getTags();
    boolean getIsCompleted();
    void setCompleted();
    void setIncomplete();
    void setStartDateTime(DateTime dateTime);
    void setEndDateTime(DateTime dateTime);
    DateTime getStartDateTime();
    DateTime getEndDateTime();
    String getTaskType();
    String getStatusString();
    String getTaskDetails();


    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(BasicTaskFeatures other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName())); // state checks here onwards
    }

    /**
     * Formats the task as text, showing all task details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName())
               .append(" Tags: ");
        builder.append(getAllTags());
        return builder.toString();
    }

    default String getAllTags() {
        final StringBuilder builder = new StringBuilder();
        Iterator<Tag> tag = getTags().iterator();
        while (tag.hasNext()) {
            Tag tagToBeDisplayed = tag.next();
            if (tagToBeDisplayed.isPriorityTag()) {
                builder.append("[" + tagToBeDisplayed.tagName + "] ");
            }
        }

        tag = getTags().iterator();
        while (tag.hasNext()) {
            Tag tagToBeDisplayed = tag.next();
            if (!tagToBeDisplayed.isPriorityTag()) {
                builder.append("[" + tagToBeDisplayed.tagName + "] ");
            }
        }

        return builder.toString();
    }
    boolean eventTaskOverlap(BasicTaskFeatures task);


}
```
###### /java/seedu/whatsnext/model/task/DateTime.java
``` java
/**
 * Represents the Date of a BasicTask
 * */
public class DateTime {
    public static final String INIT_DATETIME_VALUE = "0001/01/01 00:00";
    public static final String DEFAULT_TIME_VALUE = " 23:59";
    public static final String MESSAGE_DATE_CONSTRAINT = "Task date should be either "
            + "a day (e.g. friday) or a date with the format: DD/MM/YY (e.g. 06/07/17)\n";
    public static final String MESSAGE_DATE_INVALID = "A Task cannot be created before today.";

    private final DateFormat dateTimeFormat = new SimpleDateFormat("yyyy/dd/MM HH:mm");
    private final DateFormat dateTimeFormatDisplay = new SimpleDateFormat("EEE d MMM yyyy hh:mm aaa");
    private final DateFormat dateFormat = new SimpleDateFormat("yyyy/dd/MM");
    private final DateFormat timeFormat = new SimpleDateFormat("HH:mm");
    private Date dateValue;

    public DateTime() throws IllegalValueException {
        this(INIT_DATETIME_VALUE);
    }

    public DateTime(String dateInput) throws IllegalValueException {
        assert(dateInput != null);
        String dateInputTrim = dateInput.trim();
        initDateValue(dateInputTrim);
    }

    /**
     * Initializes the dateValue object variable base on its input parameters
     * */
    private void initDateValue(String dateInputTrim) throws IllegalValueException {
        if (dateInputTrim.equals(INIT_DATETIME_VALUE)) {
            try {
                dateValue = dateTimeFormat.parse(INIT_DATETIME_VALUE);
            } catch (java.text.ParseException e) {
                e.printStackTrace();
            }
        } else {
            List<Date> dateInputList = new PrettyTimeParser().parse(dateInputTrim);
            if (!isValidDate(dateInputList)) {
                throw new IllegalValueException(MESSAGE_DATE_CONSTRAINT);
            }
            dateValue = dateInputList.get(0);
            validateDateTime();

        }
    }

```
###### /java/seedu/whatsnext/model/task/DateTime.java
``` java
    /**
     * Prevents User from setting Tasks before today
     * @throws IllegalValueException when dateValue is before today's date
     * */
    private void validateDateTime() throws IllegalValueException {
        Date today = new Date();
        /*
        if (isBefore(today)) {
            throw new IllegalValueException(MESSAGE_DATE_INVALID);
        }*/
        if (timeFormat.format(today).equals(getTime())) {
            Calendar calendar = Calendar.getInstance();
            calendar.setTime(dateValue);
            calendar.set(Calendar.HOUR_OF_DAY, 23);
            calendar.set(Calendar.MINUTE, 59);
            calendar.set(Calendar.SECOND, 0);
            calendar.set(Calendar.MILLISECOND, 0);
            dateValue = calendar.getTime();
        }
    }

    /**
     * Checks if the list is empty
     * */
    private boolean isValidDate(List<Date> dateInputList) {
        return !dateInputList.isEmpty();
    }

    public String getDate() {
        return dateFormat.format(dateValue);
    }

    public String getTime() {
        return timeFormat.format(dateValue);
    }

    @Override
    public String toString() {
        return dateTimeFormat.format(dateValue);
    }

    public String displayDateTime() {
        return dateTimeFormatDisplay.format(dateValue);
    }

    public boolean equals(DateTime other) {
        return this.toString().equals(other.toString());
    }

    /**
     * @return true if dateValue is before parameter
     * */
    public boolean isBefore(DateTime endDateTime) {
        // dateValue is before source
        return dateValue.compareTo(endDateTime.dateValue) < 0;
    }

    public boolean isBefore(Date endDate) {
        // dateValue is before source
        return dateValue.compareTo(endDate) < 0;
    }

    /**
     * @return true when dateValue is equal or after source's dateValue
     * */
    public boolean isAfterOrEqual(DateTime source) {
        // dateValue is after or equal source
        return dateValue.compareTo(source.dateValue) >= 0;
    }

    /**
     * @return true when dateValue is equal or before source's dateValue
     * */
    public boolean isBeforeOrEqual(DateTime source) {
        // dateValue is before or equal source
        return dateValue.compareTo(source.dateValue) <= 0;
    }

    /**
     * @return true when DateValue contains INIT_DATETIME_VALUE
     * */
    public boolean isEmpty() {
        return toString().equals(INIT_DATETIME_VALUE);
    }

}
```
###### /java/seedu/whatsnext/model/task/TaskDescription.java
``` java
/**
 * Represents a Task's name in the WhatsNext application.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */

public class TaskDescription {
    public static final String INIT_DECRIPTION_VALUE = "Empty";
    public static final String MESSAGE_NAME_CONSTRAINTS =
            "Task description should only contain alphanumeric characters and spaces";
    /*
     * The first character of the task must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String TASK_DESCRIPTION_VALIDATION_REGEX = "[\\p{Alnum}][\\p{Alnum} ]*";
    public final String fullTaskDescription;

    public TaskDescription() throws IllegalValueException {
        this (INIT_DECRIPTION_VALUE);
    }

    /**
     * Validates given Description.
     * @throws IllegalValueException if given name string is invalid.
     */
    public TaskDescription(String description) throws IllegalValueException {
        requireNonNull(description);
        String trimmedDescription = description.trim();
        if (!isValidDescription(trimmedDescription)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullTaskDescription = trimmedDescription;
    }

    /**
     * Returns true if a given string is a valid task name.
     */
    public static boolean isValidDescription(String test) {
        return test.matches(TASK_DESCRIPTION_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return fullTaskDescription;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDescription // instanceof handles nulls
                && this.fullTaskDescription.equals(((TaskDescription) other).fullTaskDescription)); // state check
    }

    @Override
    public int hashCode() {
        return fullTaskDescription.hashCode();
    }
}
```
###### /java/seedu/whatsnext/model/task/TaskName.java
``` java
/**
 * Represents a Task's name in the WhatsNext application.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class TaskName {

    public static final String MESSAGE_NAME_CONSTRAINTS =
            "Task names should only contain alphanumeric characters and spaces, and it should not be blank";

    /*
     * The first character of the task must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String TASKNAME_VALIDATION_REGEX = "[\\p{Alnum}][\\p{Alnum} ]*";

    public final String fullTaskName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public TaskName(String name) throws IllegalValueException {
        requireNonNull(name);
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullTaskName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid task name.
     */
    public static boolean isValidName(String test) {
        return test.matches(TASKNAME_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return fullTaskName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskName // instanceof handles nulls
                && this.fullTaskName.equals(((TaskName) other).fullTaskName)); // state check
    }

    @Override
    public int hashCode() {
        return fullTaskName.hashCode();
    }

}
```
###### /java/seedu/whatsnext/model/util/SampleDataUtil.java
``` java
    /**
     * Returns an array of 50 BasicTask sample tasks
     * */
    public static BasicTask[] getSampleData() throws IllegalValueException {
        BasicTask[] sampleData = {
            // Floating Tasks
            new BasicTask(new TaskName("Buy Ice Cream"),
                    new TaskDescription("Buy 2 tubs of chocolate ice cream"), getTagSet("groceries")),
            new BasicTask(new TaskName("Buy some beer"),
                    new TaskDescription(), getTagSet("groceries")),
            new BasicTask(new TaskName("Buy Coffee"),
                    new TaskDescription("Buy coffee to complete CS2103 project"), getTagSet("groceries")),
            new BasicTask(new TaskName("Buy a new TV"),
                    new TaskDescription(), getTagSet("TV")),
            new BasicTask(new TaskName("Buy new Chair"),
                    new TaskDescription("Buy a new chair from ikea"), getTagSet("chair")),
            new BasicTask(new TaskName("Build a new Chair"),
                    new TaskDescription("Build a new Chair from scratch"), getTagSet("chair")),
            new BasicTask(new TaskName("BTO"), new TaskDescription("Build To Order"), getTagSet("house")),
            new BasicTask(new TaskName("Try again for BTO"),
                    new TaskDescription(), getTagSet("house")),
            new BasicTask(new TaskName("Give up on BTO"),
                    new TaskDescription(), getTagSet("house")),
            new BasicTask(new TaskName("Rent a house"),
                    new TaskDescription("Rent a house for life"), getTagSet("house")),
            new BasicTask(new TaskName("Build a house"), new TaskDescription("Build own house"), getTagSet("house")),
            new BasicTask(new TaskName("Buy a car"), new TaskDescription("Get a new car"), getTagSet("car")),
            new BasicTask(new TaskName("Buy a boat"), new TaskDescription("Get a new boat"), getTagSet("boat")),
            new BasicTask(new TaskName("Buy a bicycle"), new TaskDescription("Get a new bicycle"), getTagSet()),
            new BasicTask(new TaskName("Buy a tricycle"),
                    new TaskDescription("No money get a tricycle instead"), getTagSet()),
            // Deadline Task
            new BasicTask(new TaskName("CS2103 assignment"),
                    new TaskDescription("Complete CS2103 assignment"),
                    new DateTime("next Monday"), getTagSet("CS2103")),
            new BasicTask(new TaskName("Go to the Gym"),
                    new TaskDescription(), new DateTime("next Monday"), getTagSet("gym")),
            new BasicTask(new TaskName("Basketball tournament"),
                    new TaskDescription(), new DateTime("next tuesday, 6pm"), getTagSet("basketball")),
            new BasicTask(new TaskName("Soccer competition"),
                    new TaskDescription(), new DateTime("following monday, 7am"), getTagSet("soccer")),
            new BasicTask(new TaskName("Samuel Birthday"),
                    new TaskDescription(), new DateTime("following friday"), getTagSet("birthday")),
            new BasicTask(new TaskName("Buy beer for BBQ"), new TaskDescription("Buy beer for Jacks birthday party"),
                    new DateTime("next friday"), getTagSet("BBQ")),
            new BasicTask(new TaskName("BBQ at Jacks house"),
                    new TaskDescription("Jacks birthday party"), new DateTime("next friday"), getTagSet("BBQ")),
            new BasicTask(new TaskName("Wedding Anniversary"),
                    new TaskDescription(), new DateTime("next Sunday"), getTagSet("annivesary")),
            new BasicTask(new TaskName("Dentist Appointment"), new TaskDescription("Clean teeth"),
                    new DateTime("next sunday, 1am"), getTagSet("dental", "doctor")),
            new BasicTask(new TaskName("Doctor Appointment"),
                    new TaskDescription("physiotherapy"), new DateTime("following sunday, 1pm"), getTagSet("doctor")),
            new BasicTask(new TaskName("Lunch with John"),
                    new TaskDescription("lunch at some restaurant with john"),
                    new DateTime("following monday, 12pm"), getTagSet("lunch", "food")),
            new BasicTask(new TaskName("Dinner with Jack"),
                    new TaskDescription("dinner at some restaurant with jack"),
                    new DateTime("following tuesday, 6pm"), getTagSet("dinner", "food")),
            new BasicTask(new TaskName("Project Meeting"),
                    new TaskDescription("CS2103 project meeting with teammates"),
                    new DateTime("following weds, 6pm"), getTagSet("CS2103", "NUS")),
            new BasicTask(new TaskName("Get Ready for School"),
                    new TaskDescription(), new DateTime("following weds, 12pm"), getTagSet("CS2103", "NUS")),
            new BasicTask(new TaskName("FYP selection"), new TaskDescription("Select FYP project"),
                    new DateTime("following friday, 12pm"), getTagSet("FYP", "NUS")),
            new BasicTask(new TaskName("Bid for modules"), new TaskDescription("Module bidding"),
                    new DateTime("3 weeks from now, 8am"), getTagSet("modules", "NUS")),
            new BasicTask(new TaskName("Bid for tutorials"), new TaskDescription("Tutorial bidding"),
                    new DateTime("4 weeks from now, 8am"), getTagSet("tutorials", "NUS")),
            new BasicTask(new TaskName("Withdraw from school"),
                    new TaskDescription("Select FYP project"), new DateTime("5 weeks from now, 8am"), getTagSet("NUS")),
            new BasicTask(new TaskName("Christmas"),
                    new TaskDescription(), new DateTime("25 December"), getTagSet("holiday")),
            new BasicTask(new TaskName("Christmas Party at work"),
                    new TaskDescription(), new DateTime("23 December"), getTagSet("holiday")),
            // Event Task
            new BasicTask(new TaskName("Meet some frieds"), new TaskDescription(),
                    new DateTime("4 July 2017, 6pm"), new DateTime("4 July 2017, 7pm"), getTagSet("meeting")),
            new BasicTask(new TaskName("John bachelor party"), new TaskDescription("Bachelor party at some place"),
                    new DateTime("5 July 2017, 6pm"), new DateTime("6 July 2017, 4am"), getTagSet("wedding")),
            new BasicTask(new TaskName("John getting married"), new TaskDescription("Wedding dinner at some hotel"),
                    new DateTime("6 July 2017, 12pm"), new DateTime("6 July 2017, 9pm"), getTagSet("wedding")),
            new BasicTask(new TaskName("CS2103 Project meeting"), new TaskDescription("Project meeting for CS2103"),
                    new DateTime("20 July 8am"), new DateTime("20 July 10am"), getTagSet("nus", "CS2103")),
            new BasicTask(new TaskName("Rest for the day"), new TaskDescription("Sleep the entire day away"),
                    new DateTime("21 July 2017"), new DateTime("22 July 2017"), getTagSet("rest")),
            new BasicTask(new TaskName("Meet prof"), new TaskDescription("Project stuff"),
                    new DateTime("1 August 2017, 12pm"), new DateTime("1 August 2017, 1pm"), getTagSet("project")),
            new BasicTask(new TaskName("John getting divorce"), new TaskDescription("Go to court for settlement"),
                    new DateTime("5 August 2017, 8am"), new DateTime("5 August 2017, 10am"), getTagSet("wedding")),
            new BasicTask(new TaskName("Revise for midterms"), new TaskDescription("Revision for midterms"),
                    new DateTime("6 August 2017, 12pm"), new DateTime("7 August 2017, 12pm"), getTagSet("midterms")),

            new BasicTask(new TaskName("John getting remarried"), new TaskDescription("Wedding dinner at some hotel"),
                    new DateTime("7 August 2017, 6pm"), new DateTime("7 August 2017, 9pm"), getTagSet("wedding")),
            new BasicTask(new TaskName("Drinks with friends"), new TaskDescription(),
                    new DateTime("9 August 2017, 12pm"), new DateTime("9 August 2017, 12am"), getTagSet("meeting")),
            new BasicTask(new TaskName("Watch movie"), new TaskDescription(),
                    new DateTime("10 August 2017, 7pm"), new DateTime("10 August 2017, 9pm"), getTagSet("movie")),
            new BasicTask(new TaskName("John getting married again"),
                    new TaskDescription("Wedding dinner at some hotel"),
                    new DateTime("11 August 2017, 7pm"), new DateTime("11 August 2017, 10pm"), getTagSet("wedding")),
            new BasicTask(new TaskName("Exam Period"), new TaskDescription("Final Exam Period"),
                    new DateTime("20 August 2017"), new DateTime("25 August 2017"), getTagSet("nus", "exam")),
            new BasicTask(new TaskName("Study Break"),
                    new TaskDescription("Study break before Exams"), new DateTime("1 Dec 2017"),
                    new DateTime("2 Dec 2017"), getTagSet("nus", "exam")),
            new BasicTask(new TaskName("Winter Vacation"),
                    new TaskDescription("Post Exam vacation to Europe"), new DateTime("5 Dec 2017"),
                    new DateTime("15 Dec 2017"), getTagSet("holiday"))


        };
        return sampleData;
    }



}
```
###### /java/seedu/whatsnext/storage/XmlAdaptedTask.java
``` java
    /**
     * Converts a given Task into this class for JAXB use.

     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(BasicTask source) {
        name = source.getName().fullTaskName;
        isCompleted = source.getIsCompleted();
        tagged = new ArrayList<>();
        taskDescription = source.getDescription().toString();
        if (!source.getStartDateTime().toString().equals(DateTime.INIT_DATETIME_VALUE)) {
            startDateTime = source.getStartDateTime().displayDateTime();
        }
        if (!source.getEndDateTime().toString().equals(DateTime.INIT_DATETIME_VALUE)) {
            endDateTime = source.getEndDateTime().displayDateTime();
        }

        taskType = source.getTaskType();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

```
###### /java/seedu/whatsnext/storage/XmlAdaptedTask.java
``` java
    /**
     * Converts this jaxb-friendly adapted BasicTask object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public BasicTask toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        final TaskName name = new TaskName(this.name);
        final boolean isCompleted = this.isCompleted;
        final Set<Tag> tags = new HashSet<>(taskTags);
        final DateTime startDateTime;
        final DateTime endDateTime;
        TaskDescription taskDescription = new TaskDescription();
        if (this.taskDescription != null) {
            taskDescription = new TaskDescription(this.taskDescription);
        }

        // Event Task
        if (this.startDateTime != null && this.endDateTime != null) {
            startDateTime = new DateTime(this.startDateTime);
            endDateTime = new DateTime(this.endDateTime);
            return new BasicTask(name, taskDescription, isCompleted, startDateTime, endDateTime, tags);
        } else if (this.endDateTime != null) {
            endDateTime = new DateTime(this.endDateTime);
            return new BasicTask(name, taskDescription, isCompleted, endDateTime, tags);
        } else {
            return new BasicTask(name, taskDescription, isCompleted, tags);
        }

    }
}
```
