# A0139964M
###### /java/seedu/ticktask/logic/commands/AddCommandTest.java
``` java
    @Test
    public void execute_PastTaskAcceptedByModel_addSuccessful() throws Exception {
        ModelStubAcceptingTaskAdded modelStub = new ModelStubAcceptingTaskAdded();
        Task validTask = new TaskBuilder().withDate("01/01/2001").build();

        CommandResult commandResult = getAddCommandForTask(validTask, modelStub).execute();

        assertEquals(String.format(AddCommand.MESSAGE_PAST_TASK, validTask), commandResult.feedbackToUser);
        assertEquals(Arrays.asList(validTask), modelStub.tasksAdded);
    }

    @Test
    public void execute_PastTask_CurrTimeNullDate_AcceptedByModel_addSuccessful() throws Exception {
        LocalTime localTime = LocalTime.now();
        LocalDate currDate = LocalDate.now();
        ModelStubAcceptingTaskAdded modelStub = new ModelStubAcceptingTaskAdded();
        Task validTask = new TaskBuilder().withDate("").withTime(localTime.toString()).build();

        CommandResult commandResult = getAddCommandForTask(validTask, modelStub).execute();

        assertEquals(String.format(AddCommand.MESSAGE_PAST_TASK, validTask), commandResult.feedbackToUser);
        assertEquals(Arrays.asList(validTask), modelStub.tasksAdded);
    }

    @Test
    public void execute_PastTask_CurrDateCurrTimeAcceptedByModel_addSuccessful() throws Exception {
        LocalTime localTime = LocalTime.now();
        LocalDate currDate = LocalDate.now();
        ModelStubAcceptingTaskAdded modelStub = new ModelStubAcceptingTaskAdded();
        Task validTask = new TaskBuilder().withDate(currDate.toString()).withTime(localTime.toString()).build();

        CommandResult commandResult = getAddCommandForTask(validTask, modelStub).execute();

        assertEquals(String.format(AddCommand.MESSAGE_PAST_TASK, validTask), commandResult.feedbackToUser);
        assertEquals(Arrays.asList(validTask), modelStub.tasksAdded);
```
###### /java/seedu/ticktask/logic/commands/EditCommandTest.java
``` java
public class EditCommandTest {
    private Model model = new ModelManager(new TypicalTasks().getTypicalTickTask(), new UserPrefs());


    @Test
    public void execute_allFieldsSpecifiedUnfilteredList_success() throws Exception {
        ReadOnlyTask targetEntry = model.getFilteredTaskList().get(INDEX_FIRST_TASK.getZeroBased());
        Task validTask = new TaskBuilder().withTime("0800").withDate("01/01/2018").build();
        EditCommand.EditTaskDescriptor descriptor = new EditTaskDescriptorBuilder(validTask).build();
        EditCommand editCommand = prepareCommand(INDEX_FIRST_TASK, descriptor);
        String expectedMessage = String.format(EditCommand.MESSAGE_EDIT_TASK_SUCCESS, targetEntry, validTask);
        Model expectedModel = new ModelManager(new TypicalTasks().getTypicalTickTask(), new UserPrefs());
        expectedModel.updateTask(targetEntry,validTask);
        CommandResult result = editCommand.execute();

        assertEquals(expectedMessage, result.feedbackToUser);
        assertEquals(expectedModel, model);
    }

    @Test
    public void execute_invalidEntryIndexUnfilteredList_failure() throws Exception {
        Index outOfBoundIndex = Index.fromOneBased(model.getFilteredTaskList().size() + 1);
        EditCommand.EditTaskDescriptor descriptor = new EditTaskDescriptorBuilder().withName(VALID_NAME_MEETING).build();
        EditCommand editCommand = prepareCommand(outOfBoundIndex, descriptor);

        CommandTestUtil.assertCommandFailure(editCommand, model,
                Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
    }

    /**
     * Returns an {@code EditCommand} with parameters {@code index} and {@code descriptor}
     */
    private EditCommand prepareCommand(Index index, EditCommand.EditTaskDescriptor descriptor) {
        EditCommand editCommand = new EditCommand(index, descriptor);
        editCommand.setData(model, new CommandHistory());
        return editCommand;
    }

    @Test
    public void equals() {
        final EditCommand standardCommand = new EditCommand(INDEX_FIRST_TASK, DESC_MEETING);

        // same values -> returns true
        EditCommand.EditTaskDescriptor copyDescriptor = new EditCommand.EditTaskDescriptor(DESC_MEETING);
        EditCommand commandWithSameValues = new EditCommand(INDEX_FIRST_TASK, copyDescriptor);
        assertTrue(standardCommand.equals(commandWithSameValues));

        // same object -> returns true
        assertTrue(standardCommand.equals(standardCommand));

        // null -> returns false
        assertFalse(standardCommand.equals(null));

        // different types -> returns false
        assertFalse(standardCommand.equals(new ClearCommand(null)));

        // different index -> returns false
        assertFalse(standardCommand.equals(new EditCommand(INDEX_SECOND_TASK, DESC_EVENT)));

        // different descriptor -> returns false
        assertFalse(standardCommand.equals(new EditCommand(INDEX_FIRST_TASK,  DESC_EVENT)));
    }


}

```
###### /java/seedu/ticktask/logic/parser/DeleteCommandParserTest.java
``` java
    @Test
    public void delete_byActiveIndexSpecified_success() throws Exception {
        DeleteCommand command = deleteCommandParser.parse("delete active 1");
        assertTrue(command instanceof  DeleteCommand);
    }

    @Test
    public void delete_byCompleteIndexSpecified_success() throws Exception {
        DeleteCommand command = deleteCommandParser.parse("delete complete 1");
        assertTrue(command instanceof  DeleteCommand);
    }


    @Test
    public void delete_byNameIndexSpecified_success() throws Exception {
        DeleteCommand command = deleteCommandParser.parse("delete wash dog");
        assertTrue(command instanceof  DeleteCommand);
    }
```
###### /java/seedu/ticktask/logic/parser/parseAddCommandTest.java
``` java
public class parseAddCommandTest {
    
    private static final String MESSAGE_INVALID_FORMAT = String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                                         AddCommand.MESSAGE_USAGE);
    private static final String NAME_INVALID_NONALPHANUMERIC = "abc!";
    private static final String NAME_INVALID_EMPTY = "";
            
    private ParseAddCommand parser = new ParseAddCommand();
    @Rule
    public ExpectedException thrown = ExpectedException.none();
    
    @Test
    public void parse_emptyArgs_throwsParseException() throws Exception {
        thrown.expect(ParseException.class);
        thrown.expectMessage(String.format(AddCommand.MESSAGE_USAGE));
        parser.parse("");
    }
    
    @Test
    public void parse_validArgs_returnsAddCommand() throws Exception {
        // floating task
        Command command = parser.parse(VALID_NAME_EVENT);
        assertTrue(command instanceof AddCommand);
        
        // deadline
        command = parser.parse(VALID_NAME_MEETING + PREFIX_DATE + VALID_DATE_5_DEC);
        assertTrue(command instanceof AddCommand);
        
        // event(Date)
        command = parser.parse(VALID_NAME_EVENT + PREFIX_DATE + VALID_DATE_16_NOV + "to " + VALID_DATE_5_DEC );
        assertTrue(command instanceof AddCommand);
        
        //event (date & time)
        command = parser.parse(VALID_NAME_EVENT + PREFIX_DATE + VALID_DATE_16_NOV + "to " + VALID_DATE_5_DEC
                               + PREFIX_TIME + VALID_TIME_5PM);
        assertTrue(command instanceof AddCommand);
    }
    
    @Test
    public void parse_invalidArgsFollowedByValidArgs_returnsAddCommand() throws Exception {
        Command command = parser.parse(NAME_INVALID_NONALPHANUMERIC + PREFIX_DATE + VALID_DATE_5_DEC);
        assertTrue(command instanceof AddCommand);
    }
    
    @Test
    //Add blankspace floating task  
    public void parse_invalidBlankName_returnsAddCommand() throws Exception {
        assertParseFailure(NAME_INVALID_EMPTY, MESSAGE_INVALID_FORMAT);
    }
    
    private void assertParseFailure(String userInput, String expectedMessage) throws IllegalValueException, IndexOutOfBoundsException {
        try {
            parser.parse(userInput);

            fail("An exception should have been thrown.");
        } catch (ParseException pe) {
            assertEquals(expectedMessage, pe.getMessage());
        }
    }
}



```
###### /java/seedu/ticktask/logic/parser/parseEditCommandTest.java
``` java
public class parseEditCommandTest {
    
    private static final String NAME_DESC_MEETING = " " + PREFIX_NAME + VALID_NAME_MEETING;
    private static final String NAME_DESC_EVENT = " " + PREFIX_NAME + VALID_NAME_EVENT;
    private static final String TAG_DESC_FRIEND = " " + PREFIX_TAG + VALID_TAG_HOMEWORK;
    private static final String TAG_DESC_HUSBAND = " " + PREFIX_TAG + VALID_TAG_TODO;
    private static final String TAG_EMPTY = " " + PREFIX_TAG;
    
    private static final String INVALID_NAME_DESC = " " + PREFIX_NAME + ""; // empty names not allowed
    private static final String INVALID_TAG_DESC = " " + PREFIX_TAG + "hubby*"; // '*' not allowed in tags
    
    private static final String MESSAGE_INVALID_FORMAT =
            String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    EditCommand.MESSAGE_USAGE);
    
    private ParseEditCommand parser = new ParseEditCommand();
    
    @Test
    public void parse_missingParts_failure() throws IllegalValueException {
        // no field specified
        assertParseFailure(PREFIX_NAME + "1", MESSAGE_INVALID_FORMAT);
        
        // no index and no field specified
        assertParseFailure("", MESSAGE_INVALID_FORMAT);
    
        // no index specified
        assertParseFailure(VALID_NAME_MEETING, MESSAGE_INVALID_FORMAT);
    }
    
    @Test
    public void parse_invalidPreamble_failure() throws IllegalValueException {
        // negative index
        assertParseFailure("-5" + NAME_DESC_MEETING, MESSAGE_INVALID_FORMAT);
    
        // zero index
        assertParseFailure("0" + NAME_DESC_MEETING, MESSAGE_INVALID_FORMAT);
    
        // invalid arguments being parsed as preamble
        assertParseFailure("1 some random string", MESSAGE_INVALID_FORMAT);
    
        // invalid prefix being parsed as preamble
        assertParseFailure("1 i/ string", MESSAGE_INVALID_FORMAT);
    }

    @Test
    public void parse_invalidName_failure() throws IllegalValueException {
        assertParseFailure("" + INDEX_FIRST_TASK + PREFIX_NAME + "@", MESSAGE_INVALID_FORMAT);
    }


    @Test
    public void parse_byIndexAllFieldsSpecified_success() throws Exception {
        Index targetIndex = INDEX_SECOND_TASK;
        String userInput = "2 " + PREFIX_NAME + VALID_NAME_EVENT  + PREFIX_DATE_EDIT + VALID_DATE_5_DEC
                           + PREFIX_TIME_EDIT + VALID_TIME_5PM + PREFIX_TAG + VALID_TAG_TODO;
        EditCommand.EditTaskDescriptor descriptor = new EditTaskDescriptorBuilder().withName(VALID_NAME_MEETING).build();
        EditCommand expectedCommand = new EditCommand(targetIndex,descriptor);
        assertParseSuccess(userInput, expectedCommand);
    }
    
    @Test
    public void parse_byIndexSomeFieldsSpecified_success() throws Exception {
        Index targetIndex = INDEX_SECOND_TASK;
        String userInput = "2 " + PREFIX_NAME + VALID_NAME_EVENT  + PREFIX_DATE_EDIT + VALID_DATE_5_DEC;
        EditCommand.EditTaskDescriptor descriptor = new EditTaskDescriptorBuilder().withName(VALID_NAME_MEETING).build();
        EditCommand expectedCommand = new EditCommand(targetIndex,descriptor);
        assertParseSuccess(userInput, expectedCommand);
    }
    
    
    
    /**
     * Asserts the parsing of {@code userInput} is successful and the result matches {@code expectedCommand}
     */
    private void assertParseSuccess(String userInput, EditCommand expectedCommand) throws Exception {
        EditCommand command = parser.parse(userInput);
        assertTrue(expectedCommand instanceof EditCommand);
    }
    
        /**
         * Asserts the parsing of {@code userInput} is unsuccessful and the error message
         * equals to {@code expectedMessage}
         */
    private void assertParseFailure(String userInput, String expectedMessage) throws IllegalValueException, IndexOutOfBoundsException {
        try {
            parser.parse(userInput);
            fail("An exception should have been thrown.");
        } catch (ParseException pe) {
            assertEquals(expectedMessage, pe.getMessage());
        }
    }
}
```
###### /java/seedu/ticktask/model/task/TaskTypeTest.java
``` java
    @Test
    public void isValidTaskGetValue() throws IllegalValueException {
        String deadLine = "deadline";
        TaskType taskType = new TaskType(deadLine);
        assertEquals(taskType.getValue(),deadLine);
    }

    @Test
    public void isValidSetType() throws IllegalValueException {
        String deadLine = "deadline";
        String event = "event";
        TaskType taskType = new TaskType(deadLine);
        taskType.setValue(event);
        assertEquals(taskType.toString(),event);

    }

    @Test
    public void equals() throws IllegalValueException  {
        final TaskType standardTaskType = new TaskType(DEADLINE);
        TaskType taskTypeWithSameValue = new TaskType(DEADLINE);
        TaskType taskWithDifferentValue = new TaskType(EVENT);

        // same values -> returns true
        assertTrue(standardTaskType.equals(taskTypeWithSameValue));

        // same object -> returns true
        assertTrue(standardTaskType.equals(standardTaskType));

        // null -> returns false
        assertFalse(standardTaskType.equals(null));

        // different types -> returns false
        assertFalse(standardTaskType.equals(new ClearCommand(null)));

        // different type -> returns false
        assertFalse(standardTaskType.equals(taskWithDifferentValue));
    }
```
###### /java/seedu/ticktask/testutil/EditCommandTestUtil.java
``` java
/**
 * Utility class containing the constants required for tests related to EditCommand
 */
public class EditCommandTestUtil {
    public static final String VALID_NAME_MEETING = "Meeting ";
    public static final String VALID_NAME_EVENT = "Event ";
    public static final String VALID_TAG_HOMEWORK = "homework ";
    public static final String VALID_TAG_TODO = "todo ";
    public static final String VALID_DATE_29_JULY = "29 july ";
    public static final String VALID_DATE_5_DEC = "5 december ";
    public static final String VALID_DATE_16_NOV = "16 nov";
    public static final String VALID_TIME_5PM = "5pm ";
    public static final String VALID_TIME_1600 = "1600 ";

    
    public static final EditCommand.EditTaskDescriptor DESC_MEETING;
    public static final EditCommand.EditTaskDescriptor DESC_EVENT;
    
    static {
        try {
            DESC_MEETING = new EditTaskDescriptorBuilder().withName(VALID_NAME_MEETING).withDate(VALID_DATE_5_DEC)
                                                          .withTime(VALID_TIME_5PM).withTags(VALID_TAG_HOMEWORK);
            
            DESC_EVENT = new EditTaskDescriptorBuilder().withName(VALID_NAME_EVENT)
                    .withTags().build();
        } catch (IllegalValueException ive) {
            throw new AssertionError("Method should not fail.");
        }
    }
}
```
###### /java/seedu/ticktask/testutil/EditTaskDescriptorBuilder.java
``` java
public class EditTaskDescriptorBuilder extends EditCommand.EditTaskDescriptor {
    
        
        private EditCommand.EditTaskDescriptor descriptor;
        
        public EditTaskDescriptorBuilder() {
            descriptor = new EditCommand.EditTaskDescriptor();
        }
        
        public EditTaskDescriptorBuilder(EditCommand.EditTaskDescriptor descriptor) {
            this.descriptor = new EditCommand.EditTaskDescriptor(descriptor);
        }
        
        /**
         * Returns an {@code EditEntryDescriptor} with fields containing {@code entry}'s details
         */
        public EditTaskDescriptorBuilder(ReadOnlyTask task) throws IllegalValueException {
            descriptor = new EditCommand.EditTaskDescriptor();
            descriptor.setName(task.getName());
            descriptor.setDate(task.getDate());
            descriptor.setTime(task.getTime());
            descriptor.setTags(task.getTags());
        }
        
        
        public EditTaskDescriptorBuilder withName(String name) throws IllegalValueException {
            ParserUtil.parseName(Optional.of(name)).ifPresent(descriptor::setName);
            return this;
        }
    
        public EditTaskDescriptorBuilder withDate(String date) throws IllegalValueException {
            ParserUtil.parseDate(Optional.of(date)).ifPresent(descriptor::setDate);
            return this;
        }
    
        public EditTaskDescriptorBuilder withTime(String time) throws IllegalValueException {
            ParserUtil.parseTime(Optional.of(time)).ifPresent(descriptor::setTime);
            return this;
        }
        
        public EditTaskDescriptorBuilder withTags(String... tags) throws IllegalValueException {
            descriptor.setTags(ParserUtil.parseTags(Arrays.asList(tags)));
            return this;
        }
        
        public EditCommand.EditTaskDescriptor build() {
            return descriptor;
        }
    }
```
